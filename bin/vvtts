#!/bin/env ruby

# 引数のパースのため
require 'optparse'

# HTTPリクエストを実行するため
require 'net/http'

# URLエンコードを実行するため
require 'cgi'

# ファイル処理を行うため
require 'fileutils'

# JSON処理を行うため
require 'json'

# 再生コマンドを実行するため
require "open3"

# バージョン
VERSION="1.4.0"


#------
# 設定
#------

# VOICEVOX ENGINEのバージョンと、指定できるSpeakerIDの最大値
VERSION_TO_MAX_SPEAKER_ID = {
  "0.0.0" => 8,
  "0.9.1" => 9,
  "0.9.4" => 10,
  "0.11.0" => 14,
  "0.11.4" => 19,
  "0.12.2" => 20,
  "0.12.3" => 21,
  "0.12.4" => 22,
  "0.13.1" => 35,
  "0.13.2" => 38,
  "0.13.3" => 50,
  "0.14.3" => 53,
  "0.14.4" => 60,
  "0.14.5" => 65,
  "0.14.6" => 74,
}

# デフォルトの設定ファイル
config_file_path = "#{File.dirname(__dir__)}/etc/config.rb"

# デフォルトの置換リストファイル
replace_list_file_path = "#{File.dirname(__dir__)}/etc/replace.list"

# 設定ファイルがオプションで指定されていたら上書き
ARGV.each_with_index{|value,index|
  if value =~ /^(-c|--config)$/ then
    config_file_path = ARGV[index+1]
  elsif value =~ /^--config=(.*)$/ then
    config_file_path = $1
  end
}

# 設定ファイルを読み込む
if File.exist?(config_file_path)
  require_relative "#{config_file_path}"
else
  STDOUT.print "設定ファイル \"#{config_file_path}\" が見つかりません\n"
  exit 1
end


#----------
# 関数定義
#----------

# デバッグメッセージを表示する関数
def debug_print(message)
  if @debug_flag == 1 then
    STDERR.print "Debug: #{message}\n"
  end
end


# 正しい JSON かどうかチェックする関数
def check_format(json)
  begin
    JSON.parse(json)
    return true
  rescue JSON::ParserError => e
    return false
  end
end


# エンジンで指定可能なSpeakerID一覧を取得する関数
def get_available_speakerid(server, mode='get', type='voicevox')
  uri = URI.parse("http://#{server}/speakers")
  http = Net::HTTP.new(uri.host, uri.port)
  res = nil
  # サーバから情報を取得
  begin
    Timeout.timeout(5){
      res = http.get(uri)
    }
  rescue Timeout::Error
    res = nil
  end
  # サーバから返ってきたら
  if not res.nil? then
    # JSONフォーマットが正しいかチェック
    if not check_format(res.body) then
      debug_print("データが正しいJSON形式ではありません\n")
      return nil
    end
    # 利用可能なSpeakerIDを格納する配列
    speaker_ids = Array.new
    # JSONをハッシュに変換
    debug_print("speakers=#{res.body}")
    speaker_data = JSON.parse(res.body)
    # modeがgetだったら取得したSpeaker IDを配列で返す
    if mode == 'get' then
      speaker_data.each{|data|
        data['styles'].each{|style|
          # VOICEVOX NEMOの場合は10000を引いたIDを返す
          if type == "voicevox_nemo" then
            speaker_ids << style['id'].to_i - 10000
          else
            speaker_ids << style['id']
          end
        }
      }
      # 指定可能なSpeakerID一覧を配列で返す
      return speaker_ids.sort
    # modeがprintだったら取得した情報を表示する
    else
      speaker_info = Hash.new
      speaker_data.each{|data|
        if speaker_info[data['name']].nil? then
          speaker_info[data['name']] = Hash.new
        end
        data['styles'].each{|style|
          speaker_info[data['name']][style['id']] = style['name']
        }
      }
      speaker_info.each{|name,value|
        STDERR.print "#{name}\n"
        value.sort.each{|id,st|
          if type == 'voicevox_nemo' then
            temp = "n#{id - 10000}"
            STDERR.print "    #{sprintf("%8s",temp)}  #{st}\n"
          elsif type == 'coeiroink' then
            temp = "c#{id}"
            STDERR.print "    #{sprintf("%8s",temp)}  #{st}\n"
          else
            STDERR.print "    #{sprintf("%8d",id)}  #{st}\n"
          end
        }
        STDERR.print "\n"
      }
    end
  # サーバからデータが返ってこなかったら
  else
    debug_print("voicevox engineで利用可能なSpeakerIDを取得できません")
    return nil
  end
end

# 文字列をwavデータに変換する関数
def text2wav(type, server, text, speaker, query_speaker, param_speed, param_pitch, param_intonation, param_volume, sample_rate=0)
  if type == "voicevox" then
    # speakerの値チェック
    if speaker.to_i < 0 or @max_speaker_id < speaker.to_i then
      STDERR.print "speaker の値が正しくありません (\"#{speaker}\")\n"
    end
    # query_speakerの値チェック
    if query_speaker != "" and ( query_speaker.to_i < 0 or @max_speaker_id < query_speaker.to_i ) then
      STDERR.print "query_speaker の値が正しくありません (\"#{query_speaker}\")\n"
    end
  elsif type == "voicevox_nemo" then
    # speakerの値チェック
    if not @voicevox_nemo_available_speakers.include?(speaker) then
      STDERR.print "speaker の値が正しくありません (\"#{speaker}\")\n"
    end
    # query_speakerの値チェック
    if query_speaker != "" and (not @voicevox_nemo_available_speakers.include?(query_speaker)) then
      STDERR.print "query_speaker の値が正しくありません (\"#{query_speaker}\")\n"
    end
  elsif type == "coeiroink" then
    # speakerの値チェック
    if not @coeiroink_available_speakers.include?(speaker) then
      STDERR.print "speaker の値が正しくありません (\"#{speaker}\")\n"
    end
    # query_speakerの値チェック
    if query_speaker != "" and (not @coeiroink_available_speakers.include?(query_speaker)) then
      STDERR.print "query_speaker の値が正しくありません (\"#{query_speaker}\")\n"
    end
  end
  # URLエンコード
  enc_text = CGI.escape(text)
  # デバッグメッセージ
  debug_print("enc_text=#{enc_text}")
  if query_speaker == "" then
    if type == "voicevox_nemo" then
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/audio_query?text=#{enc_text}&speaker=#{speaker.to_i + 10000}\"")
      # JSON取得のためのURLをセット
      uri = URI("http://#{server}/audio_query?text=#{enc_text}&speaker=#{speaker.to_i + 10000}")
    else
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/audio_query?text=#{enc_text}&speaker=#{speaker}\"")
      # JSON取得のためのURLをセット
      uri = URI("http://#{server}/audio_query?text=#{enc_text}&speaker=#{speaker}")
    end
  else
    if type == "voicevox_nemo" then
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/audio_query?text=#{enc_text}&speaker=#{query_speaker.to_i + 10000}\"")
      # JSON取得のためのURLをセット
      uri = URI("http://#{server}/audio_query?text=#{enc_text}&speaker=#{query_speaker.to_i + 10000}")
    else
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/audio_query?text=#{enc_text}&speaker=#{query_speaker}\"")
      # JSON取得のためのURLをセット
      uri = URI("http://#{server}/audio_query?text=#{enc_text}&speaker=#{query_speaker}")
    end
  end
  # JSONの取得
  res = Net::HTTP.post_form(uri, 'body' => nil)
  # デバッグメッセージ
  debug_print("res=#{res.body}")
  # JSON取得に成功したら、音声データ変換を実行
  if res.code == "200" then
    # VOICEVOXの場合の補正
    if type == "voicevox" then
      # 設定ファイルで補正設定があれば
      if VOICEVOX_CORRECT_MATRIX.key?(speaker.to_s) then
        # 話速補正
        param_speed = sprintf("%0.2f", param_speed.to_f * VOICEVOX_CORRECT_MATRIX[speaker.to_s][0] )
        # ピッチ補正
        param_pitch = sprintf("%0.2f", param_pitch.to_f + VOICEVOX_CORRECT_MATRIX[speaker.to_s][1] )
        # イントネーション補正
        param_intonation = sprintf("%0.2f", param_intonation.to_f * VOICEVOX_CORRECT_MATRIX[speaker.to_s][2] )
        # 音量補正
        param_volume = sprintf("%0.2f", param_volume.to_f * VOICEVOX_CORRECT_MATRIX[speaker.to_s][3] )
      end
    # VOICEVOX NEMOの場合の補正
    elsif type == "voicevox_nemo" then
      # 設定ファイルで補正設定があれば
      if VOICEVOX_NEMO_CORRECT_MATRIX.key?(speaker.to_s) then
        # 話速補正
        param_speed = sprintf("%0.2f", param_speed.to_f * VOICEVOX_NEMO_CORRECT_MATRIX[speaker.to_s][0] )
        # ピッチ補正
        param_pitch = sprintf("%0.2f", param_pitch.to_f + VOICEVOX_NEMO_CORRECT_MATRIX[speaker.to_s][1] )
        # イントネーション補正
        param_intonation = sprintf("%0.2f", param_intonation.to_f * VOICEVOX_NEMO_CORRECT_MATRIX[speaker.to_s][2] )
        # 音量補正
        param_volume = sprintf("%0.2f", param_volume.to_f * VOICEVOX_NEMO_CORRECT_MATRIX[speaker.to_s][3] )
      end
    # COEIROINKの場合の補正
    elsif type == "coeiroink" then
      # 設定ファイルで補正設定があれば
      if COEIROINK_CORRECT_MATRIX.key?(speaker.to_s) then
        # 話速補正
        param_speed = sprintf("%0.2f", param_speed.to_f * COEIROINK_CORRECT_MATRIX[speaker.to_s][0] )
        # ピッチ補正
        param_pitch = sprintf("%0.2f", param_pitch.to_f + COEIROINK_CORRECT_MATRIX[speaker.to_s][1] )
        # イントネーション補正
        param_intonation = sprintf("%0.2f", param_intonation.to_f * COEIROINK_CORRECT_MATRIX[speaker.to_s][2] )
        # 音量補正
        param_volume = sprintf("%0.2f", param_volume.to_f * COEIROINK_CORRECT_MATRIX[speaker.to_s][3] )
      end
    end
    # 各種パラメータがデフォルト値でない場合、値をセットする
    if param_speed != 1.0 or param_pitch != 0.0 or param_intonation != 1.0 or param_volume != 1.0 then
      # 各種パラメータをセット
      json_hash = JSON.parse(res.body)
      json_hash["speedScale"] = param_speed
      json_hash["pitchScale"] = param_pitch
      json_hash["intonationScale"] = param_intonation
      json_hash["volumeScale"] = param_volume
      res.body = JSON.generate(json_hash)
    end
    # サンプルレートが引数で指定された場合セットする
    if sample_rate != 0 then
      json_hash = JSON.parse(res.body)
      json_hash["outputSamplingRate"] = sample_rate
      res.body = JSON.generate(json_hash)
    end
    # デバッグメッセージ
    debug_print("modified res=#{res.body}")
    # JSONを音声データに変換
    headers = { 'Content-Type' => 'application/json' }
    uri = URI.parse("http://#{server}/")
    http = Net::HTTP.new(uri.host, uri.port)
    http.read_timeout = HTTP_TIMEOUT
    if type == "voicevox_nemo" then
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/synthesis?speaker=#{speaker.to_i + 10000}\"")
      # 音声データを取得
      voice = http.post("/synthesis?speaker=#{speaker.to_i + 10000}", res.body, headers)
    else
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/synthesis?speaker=#{speaker}\"")
      # 音声データを取得
      voice = http.post("/synthesis?speaker=#{speaker}", res.body, headers)
    end
    # デバッグメッセージ
    debug_print("リターンコード=#{voice.code} データサイズ=#{voice.body.size}")
    # 音声データ変換に成功したら
    if voice.code == "200" then
      # 音声データを返す
      return voice.body
    # 音声データ変換に失敗したら
    elsif voice.code == "500" then
      STDERR.print "文字数が多すぎるため音声データ変換に失敗しました (ret=#{voice.code} json_size=#{res.body.length})\n"
      return nil
    else
      STDERR.print "音声データ変換に失敗しました (ret=#{voice.code})\n"
      return nil
    end
  # JSON取得に失敗したら
  else
    STDERR.print "クエリ作成に失敗しました (ret=#{res.code})\n"
    return nil
  end
end


# 文字列を2者の音声をモーフィングしたwavデータに変換する関数
def text2wav_morph(type, server, text, base_speaker, target_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, sample_rate=0)
  if type == "voicevox" then
    # base_speakerの値チェック
    if base_speaker.to_i < 0 or @max_speaker_id < base_speaker.to_i then
      STDERR.print "base_speaker の値が正しくありません (\"#{base_speaker}\")\n"
    end
    # target_speakerの値チェック
    if target_speaker.to_i < 0 or @max_speaker_id < target_speaker.to_i then
      STDERR.print "target_speaker の値が正しくありません (\"#{target_speaker}\")\n"
    end
    # query_speakerの値チェック
    if query_speaker != "" and ( query_speaker.to_i < 0 or @max_speaker_id < query_speaker.to_i ) then
      STDERR.print "query_speaker の値が正しくありません (\"#{query_speaker}\")\n"
    end
  elsif type == "voicevox_nemo" then
    # base_speakerの値チェック
    if not @voicevox_nemo_available_speakers.include?(base_speaker) then
      STDERR.print "base_speaker の値が正しくありません (\"#{base_speaker}\")\n"
    end
    # target_speakerの値チェック
    if not @voicevox_nemo_available_speakers.include?(target_speaker) then
      STDERR.print "target_speaker の値が正しくありません (\"#{target_speaker}\")\n"
    end
    # query_speakerの値チェック
    if query_speaker != "" and (not @voicevox_nemo_available_speakers.include?(query_speaker)) then
      STDERR.print "query_speaker の値が正しくありません (\"#{query_speaker}\")\n"
    end
  elsif type == "coeiroink" then
    # base_speakerの値チェック
    if not @coeiroink_available_speakers.include?(base_speaker) then
      STDERR.print "base_speaker の値が正しくありません (\"#{base_speaker}\")\n"
    end
    # target_speakerの値チェック
    if not @coeiroink_available_speakers.include?(target_speaker) then
      STDERR.print "target_speaker の値が正しくありません (\"#{target_speaker}\")\n"
    end
    # query_speakerの値チェック
    if query_speaker != "" and (not @coeiroink_available_speakers.include?(query_speaker)) then
      STDERR.print "query_speaker の値が正しくありません (\"#{query_speaker}\")\n"
    end
  end
  # URLエンコード
  enc_text = CGI.escape(text)
  # デバッグメッセージ
  debug_print("enc_text=#{enc_text}")
  if query_speaker == "" then
    if type == "voicevox_nemo" then
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/audio_query?text=#{enc_text}&speaker=#{base_speaker.to_i + 10000}\"")
      # JSON取得のためのURLをセット
      uri = URI("http://#{server}/audio_query?text=#{enc_text}&speaker=#{base_speaker.to_i + 10000}")
    else
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/audio_query?text=#{enc_text}&speaker=#{base_speaker}\"")
      # JSON取得のためのURLをセット
      uri = URI("http://#{server}/audio_query?text=#{enc_text}&speaker=#{base_speaker}")
    end
  else
    if type == "voicevox_nemo" then
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/audio_query?text=#{enc_text}&speaker=#{query_speaker.to_i + 10000}\"")
      # JSON取得のためのURLをセット
      uri = URI("http://#{server}/audio_query?text=#{enc_text}&speaker=#{query_speaker.to_i + 10000}")
    else
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/audio_query?text=#{enc_text}&speaker=#{query_speaker}\"")
      # JSON取得のためのURLをセット
      uri = URI("http://#{server}/audio_query?text=#{enc_text}&speaker=#{query_speaker}")
    end
  end
  # JSONの取得
  res = Net::HTTP.post_form(uri, 'body' => nil)
  # デバッグメッセージ
  debug_print("res=#{res.body}")
  # JSON取得に成功したら、音声データ変換を実行
  if res.code == "200" then
    # VOICEVOXの場合の補正
    if type == "voicevox" then
      # 設定ファイルで補正設定があれば
      if VOICEVOX_CORRECT_MATRIX.key?(base_speaker.to_s) and VOICEVOX_CORRECT_MATRIX.key?(target_speaker.to_s) then
        # 話速補正
        param_speed = sprintf("%0.2f", param_speed.to_f * ( (VOICEVOX_CORRECT_MATRIX[base_speaker.to_s][0] * (1.0 - morph_rate.to_f)) + (VOICEVOX_CORRECT_MATRIX[target_speaker.to_s][0] * morph_rate.to_f) ) )
        # ピッチ補正
        param_pitch = sprintf("%0.2f", param_pitch.to_f + ( (VOICEVOX_CORRECT_MATRIX[base_speaker.to_s][1] * (1.0 - morph_rate.to_f)) + (VOICEVOX_CORRECT_MATRIX[target_speaker.to_s][1] * morph_rate.to_f) ) )
        # イントネーション補正
        param_intonation = sprintf("%0.2f", param_intonation.to_f * ( (VOICEVOX_CORRECT_MATRIX[base_speaker.to_s][2] * (1.0 - morph_rate.to_f)) + (VOICEVOX_CORRECT_MATRIX[target_speaker.to_s][2] * morph_rate.to_f) ) )
        # 音声補正
        param_volume = sprintf("%0.2f", param_volume.to_f * ( (VOICEVOX_CORRECT_MATRIX[base_speaker.to_s][3] * (1.0 - morph_rate.to_f)) + (VOICEVOX_CORRECT_MATRIX[target_speaker.to_s][3] * morph_rate.to_f) ) )
      end
    # VOICEVOX NEMOの場合の補正
    elsif type == "voicevox_nemo" then
      # 設定ファイルで補正設定があれば
      if VOICEVOX_NEMO_CORRECT_MATRIX.key?(base_speaker.to_s) and VOICEVOX_NEMO_CORRECT_MATRIX.key?(target_speaker.to_s) then
        # 話速補正
        param_speed = sprintf("%0.2f", param_speed.to_f * ( (VOICEVOX_NEMO_CORRECT_MATRIX[base_speaker.to_s][0] * (1.0 - morph_rate.to_f)) + (VOICEVOX_NEMO_CORRECT_MATRIX[target_speaker.to_s][0] * morph_rate.to_f) ) )
        # ピッチ補正
        param_pitch = sprintf("%0.2f", param_pitch.to_f + ( (VOICEVOX_NEMO_CORRECT_MATRIX[base_speaker.to_s][1] * (1.0 - morph_rate.to_f)) + (VOICEVOX_NEMO_CORRECT_MATRIX[target_speaker.to_s][1] * morph_rate.to_f) ) )
        # イントネーション補正
        param_intonation = sprintf("%0.2f", param_intonation.to_f * ( (VOICEVOX_NEMO_CORRECT_MATRIX[base_speaker.to_s][2] * (1.0 - morph_rate.to_f)) + (VOICEVOX_NEMO_CORRECT_MATRIX[target_speaker.to_s][2] * morph_rate.to_f) ) )
        # 音声補正
        param_volume = sprintf("%0.2f", param_volume.to_f * ( (VOICEVOX_NEMO_CORRECT_MATRIX[base_speaker.to_s][3] * (1.0 - morph_rate.to_f)) + (VOICEVOX_NEMO_CORRECT_MATRIX[target_speaker.to_s][3] * morph_rate.to_f) ) )
      end
    # COEIROINKの場合の補正
    elsif type == "coeiroink" then
      # 設定ファイルで補正設定があれば
      if COEIROINK_CORRECT_MATRIX.key?(base_speaker.to_s) and COEIROINK_CORRECT_MATRIX.key?(target_speaker.to_s) then
        # 話速補正
        param_speed = sprintf("%0.2f", param_speed.to_f * ( (COEIROINK_CORRECT_MATRIX[base_speaker.to_s][0] * (1.0 - morph_rate.to_f)) + (COEIROINK_CORRECT_MATRIX[target_speaker.to_s][0] * morph_rate.to_f) ) )
        # ピッチ補正
        param_pitch = sprintf("%0.2f", param_pitch.to_f + ( (COEIROINK_CORRECT_MATRIX[base_speaker.to_s][1] * (1.0 - morph_rate.to_f)) + (COEIROINK_CORRECT_MATRIX[target_speaker.to_s][1] * morph_rate.to_f) ) )
        # イントネーション補正
        param_intonation = sprintf("%0.2f", param_intonation.to_f * ( (COEIROINK_CORRECT_MATRIX[base_speaker.to_s][2] * (1.0 - morph_rate.to_f)) + (COEIROINK_CORRECT_MATRIX[target_speaker.to_s][2] * morph_rate.to_f) ) )
        # 音声補正
        param_volume = sprintf("%0.2f", param_volume.to_f * ( (COEIROINK_CORRECT_MATRIX[base_speaker.to_s][3] * (1.0 - morph_rate.to_f)) + (COEIROINK_CORRECT_MATRIX[target_speaker.to_s][3] * morph_rate.to_f) ) )
      end
    end
    # 各種パラメータがデフォルト値でない場合、値をセットする
    if param_speed != 1.0 or param_pitch != 0.0 or param_intonation != 1.0 or param_volume != 1.0 then
      # 各種パラメータをセット
      json_hash = JSON.parse(res.body)
      json_hash["speedScale"] = param_speed
      json_hash["pitchScale"] = param_pitch
      json_hash["intonationScale"] = param_intonation
      json_hash["volumeScale"] = param_volume
      res.body = JSON.generate(json_hash)
    end
    # サンプルレートが引数で指定された場合セットする
    if sample_rate != 0 then
      json_hash = JSON.parse(res.body)
      json_hash["outputSamplingRate"] = sample_rate
      res.body = JSON.generate(json_hash)
    end
    # デバッグメッセージ
    debug_print("modified res=#{res.body}")
    # JSONを音声データに変換
    headers = { 'Content-Type' => 'application/json' }
    uri = URI.parse("http://#{server}/")
    http = Net::HTTP.new(uri.host, uri.port)
    http.read_timeout = HTTP_TIMEOUT
    if type == "voicevox_nemo" then
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/synthesis_morphing?base_speaker=#{base_speaker.to_i + 10000}&target_speaker=#{target_speaker.to_i + 10000}&morph_rate=#{morph_rate}\"")
      # 音声データを取得
      voice = http.post("/synthesis_morphing?base_speaker=#{base_speaker.to_i + 10000}&target_speaker=#{target_speaker.to_i + 10000}&morph_rate=#{morph_rate}", res.body, headers)
    else
      # デバッグメッセージ
      debug_print("URI=\"http://#{server}/synthesis_morphing?base_speaker=#{base_speaker}&target_speaker=#{target_speaker}&morph_rate=#{morph_rate}\"")
      # 音声データを取得
      voice = http.post("/synthesis_morphing?base_speaker=#{base_speaker}&target_speaker=#{target_speaker}&morph_rate=#{morph_rate}", res.body, headers)
    end
    # デバッグメッセージ
    debug_print("リターンコード=#{voice.code} データサイズ=#{voice.body.size}")
    # 音声データ変換に成功したら
    if voice.code == "200" then
      # 音声データを返す
      return voice.body
    # 音声データ変換に失敗したら
    elsif voice.code == "500" then
      STDERR.print "文字数が多すぎるため音声データ変換に失敗しました (ret=#{voice.code} json_size=#{res.body.length})\n"
      return nil
    else
      STDERR.print "音声データ変換に失敗しました (ret=#{voice.code})\n"
      return nil
    end
  # JSON取得に失敗したら
  else
    STDERR.print "クエリ作成に失敗しました (ret=#{res.code})\n"
    return nil
  end
end


# 置換リストを読み込む関数
def load_replace_list(replace_list_file_path)
  # 置換前文字列と置換後対応を格納するハッシュ
  repl_hash = Hash.new
  # dict.datファイルがあれば読み込む
  if File.exist?(replace_list_file_path) then
    # １行づつ処理
    File.open(replace_list_file_path){|f|
      f.each_line{|line|
        # 行頭が「#」以外の行を置換リストとして読み込む
        if line !~ /^#/ then
          # タブ区切りで、タブ前を文字列、タブ後ろを読みとしてハッシュに格納
          if line =~ /^(.+)\t(.+)$/ then
            repl_hash[$1] = $2
          end
        end
      }
    }
  end
  # ハッシュを返す
  return repl_hash
end


# 音声データを再生する関数
def play_wav(play_command, wavdata, rdp_flag)
  debug_print("再生します (datasize=#{wavdata.size})")
  # aplayコマンドで再生する場合
  if play_command == "aplay" then
    # オプションで「--rdp」が指定されている場合
    if rdp_flag == 1 then
      play_cmd = "aplay -D pulse"
    # オプションで「--no-rdp」が指定されている場合
    elsif rdp_flag == 2 then
      play_cmd = "aplay -D #{APLAY_VVTTS_DEVICE}"
    # オプションで指定されていない場合は自動判別
    else
      # XRDP上のターミナルでない場合
      if ENV['XRDP_PULSE_SINK_SOCKET'].nil? or ENV['XRDP_PULSE_SINK_SOCKET'].empty? then
        play_cmd = "aplay -D #{APLAY_VVTTS_DEVICE}"
      # XRDP上のターミナルの場合
      else
        play_cmd = "aplay -D pulse"
      end
    end
  # sox(play)コマンドで再生する場合
  elsif play_command == "sox" then
    # オプションで「--no-rdp」が指定されている場合
    if rdp_flag == 2 then
      # 環境変数「AUDIODEV」で再生するデバイスを指定
      ENV['AUDIODEV'] = SOX_VVTTS_DEVICE
    # オプションで指定されていない場合は自動判別
    elsif rdp_flag == 0 then
      # XRDP上のターミナルでない場合
      if ENV['XRDP_PULSE_SINK_SOCKET'].nil? or ENV['XRDP_PULSE_SINK_SOCKET'].empty? then
        ENV['AUDIODEV'] = SOX_VVTTS_DEVICE
      end
    end
    # 再生コマンド
    play_cmd = "play -"
  # 再生コマンドの指定が「aplay」「sox」でもない場合はエラーとする
  else
    STDERR.print "再生コマンドの指定が正しくありません\n"
    exit 1
  end
  # 再生コマンドにパイプで音声データを渡して実行
  debug_print("再生コマンド \"#{play_cmd}\"")
  Open3.capture3(play_cmd, :stdin_data=>wavdata)
end


# 指定されたサンプリング周波数、時間(秒)の無音データを作成する関数
def silent_wav_data(sample_rate, silent_time)
  # データを格納する変数
  zero_data = Array.new
  # データの個数を求める
  num = (sample_rate * silent_time).floor.to_i
  # 求めた個数分繰り返し
  num.times{|n|
    zero_data << 0
  }
  # バイナリデータの作成(16bit signed shortに変換)
  silent_data = zero_data.pack('s*')
  # バイナリデータを返す
  return silent_data
end


# wavデータの配列を結合して1つのwavデータに変換する関数
def unite_wav(wavs,interval_time,first_silent_time,last_silent_time,sample_rate)
  # デバッグメッセージ
  debug_print("#{wavs.length} つの WAV データを #{interval_time} 秒間隔で結合します")
  # 出力データとサイズを格納する変数
  output_wav = Array.new
  output_wav_size = 0
  # 先頭の無音時間が指定されていたらセットする
  if first_silent_time.to_f > 0.0 then
    # 無音データの作成
    first_silent = silent_wav_data(sample_rate, first_silent_time.to_f)
    # デバッグメッセージ
    debug_print("first_silent.size=#{first_silent.size}")
    # 無音データを先頭にセット
    output_wav << first_silent
    output_wav_size += first_silent.size
  end
  # 間に挟む無音時間が0.0秒より大きい場合
  if interval_time.to_f > 0.0 then
    # 無音データの作成
    silent_interval = silent_wav_data(sample_rate, interval_time.to_f)
    # デバッグメッセージ
    debug_print("silent_interval.size=#{silent_interval.size}")
  end
  # 与えられたWAVデータの配列を順に処理
  wavs.each {|data|
    # ヘッダ情報(12バイト)
    #header = data.slice(0,12)
    #riff = header.slice(0,4)
    #data_size = header.slice(4,4).unpack('V')[0].to_i
    #wave = header.slice(8,4)
    # デバッグメッセージ
    #debug_print("riff=#{riff} data_size=#{data_size} wave=#{wave}")
    # fmt チャンクの読み出し(普通は8バイト+データ16バイト)
    chunk = data.slice(12,8)
    chunk_name = chunk.slice(0,4)
    chunk_size = chunk.slice(4,4).unpack("V")[0].to_i
    chunk_data = data.slice(20,chunk_size)
    format_id = chunk_data.slice(0,2).unpack('c')[0]
    format_channel = chunk_data.slice(2,2).unpack('c')[0]
    format_hz = chunk_data.slice(4,4).unpack('V').join.to_i
    format_bytePerSec = chunk_data.slice(8,4).unpack('V').join.to_i
    format_blockSize = chunk_data.slice(12,2).unpack('c')[0]
    format_bitPerSample = chunk_data.slice(14,2).unpack('c')[0]
    # fmt チャンクは結合後も変わらないため、使いまわす用に丸ごとグローバル変数に保存しておく
    @fmt_chunk = data.slice(12, chunk_size+8)
    # デバッグメッセージ
    debug_print("name=#{chunk_name} size=#{chunk_size}\nid=#{format_id} channel=#{format_channel} hz=#{format_hz} bytePerSec=#{format_bytePerSec} blockSize=#{format_blockSize} bitPerSample=#{format_bitPerSample}")
    # data チャンクの読み出し位置(dataチャンクに音声データが入っている)
    chunk_start = 20 + chunk_size.to_i
    # data チャンクの読み出し
    chunk2 = data.slice(chunk_start,8)
    chunk_name2 = chunk2.slice(0,4)
    chunk_size2 = chunk2.slice(4,4).unpack("V")[0].to_i
    chunk_data2 = data.slice(chunk_start+8,chunk_size2)
    # デバッグメッセージ
    debug_print("name2=#{chunk_name2} size2=#{chunk_size2}")
    # 先頭以外の場合、間の無音データを挿入
    if output_wav.length > 0 and interval_time > 0.0 then
      output_wav << silent_interval
      output_wav_size += silent_interval.size
    end
    # 音声データを追加
    output_wav << chunk_data2
    # 音声データサイズを足す
    output_wav_size += chunk_size2.to_i
    # デバッグメッセージ
    debug_print("output_wav_size=#{output_wav_size}")
  }
  # 最後の無音時間が指定されていたらセットする
  if last_silent_time.to_f > 0.0 then
    # 無音データの作成
    last_silent = silent_wav_data(sample_rate, last_silent_time.to_f)
    # デバッグメッセージ
    debug_print("last_silent.size=#{last_silent.size}")
    # 無音データを最後に追加
    output_wav << last_silent
    output_wav_size += last_silent.size
  end
  # 出力データの作成
  # サイズ計算
  header_file_size = 4
  # fmt チャンクサイズを追加
  header_file_size += 8 + 16
  # data チャンクサイズを追加
  header_file_size += 8 + output_wav_size
  # ヘッダ、fmtチャンク、dataチャンクを結合
  outdata = 'RIFF' + [header_file_size].pack('V') + 'WAVE'
  outdata += @fmt_chunk
  outdata += 'data' + [output_wav_size].pack('V') + output_wav.join
  return outdata
end


# wavファイルをmp3ファイルにコンバートする関数
def conv2mp3(conv_command, input_wav_file, output_mp3_file)
  # 変換コマンドがsoxだったら
  if conv_command == "sox" then
    # soxコマンドを使用して変換する
    debug_print("mp3変換コマンド \"sox #{input_wav_file}.wav #{SOX_OPT1} #{output_mp3_file}.mp3 #{SOX_OPT2}\"")
    system("sox #{input_wav_file}.wav #{SOX_OPT1} #{output_mp3_file}.mp3 #{SOX_OPT2} >/dev/null 2>&1")
  # 変換コマンドがffmpegだったら
  elsif conv_command == "ffmpeg" then
    # ffmpegコマンドを使用して変換する
    debug_print("mp3変換コマンド \"ffmpeg -i #{input_wav_file}.wav #{FFMPEG_OPT} #{output_mp3_file}.mp3\"")
    system("ffmpeg -i #{input_wav_file}.wav #{FFMPEG_OPT} #{output_mp3_file}.mp3 >/dev/null 2>&1")
  # 変換コマンドがそれ以外だったら
  else
    STDERR.print "mp3変換コマンドとして\"#{conv_command}\"は利用できません\n"
    exit 1
  end
  # 変換が成功したら
  if $?.exitstatus == 0 then
    # wavファイルを削除
    FileUtils.rm("#{input_wav_file}.wav")
    return 0
  else
    STDERR.print "\"#{input_wav_file}.wav\" から \"#{output_mp3_file}.mp3\" への変換に失敗しました\n"
    return 1
  end
end


# スレッドで実行する処理
def thread_proc(type, server, text, speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, sample_rate )
  # テキストはコピーしてから処理(スレッド失敗時に元のテキストで処理したいため)
  proc_text = text.clone
  begin
    # 文頭の「#{s1,q8}」のような記述から声の種類のパラメータを変更
    if proc_text =~ /^ *#\{ *([a-zA-Z0-9,\-\. ]+) *\} */ then
      speaker_element = Array.new
      speaker_element = $1.split(",")
      # マッチングした記述を順に処理
      speaker_element.each {|temp|
        # もし、「s<数字>」だったら声の種類を変更
        if temp =~ /^ *s([0-9]+) *$/ then
          speaker = $1.to_i
        # もし、「q<数字>」だったら、クエリの声の種類を変更
        elsif temp =~ /^ *q([0-9]+) *$/ then
          query_speaker = $1.to_i
        # もし、「qx」「qX」だったら、クエリの声の種類を削除
        elsif temp =~ /^ *q[xX] *$/ then
          query_speaker = ""
        # もし、「m<数字>」だったら、モーフィング先の声の種類を変更
        elsif temp =~ /^ *m([0-9]+) *$/ then
          morph_speaker = $1.to_i
        # もし、「mx」「mX」だったら、モーフィング先の声の種類を削除
        elsif temp =~ /^ *m[xX] *$/ then
          morph_speaker = ""
          morph_rate = ""
        # もし、「r<小数>」だったら、モーフィングレートを変更
        elsif temp =~ /^ *r([0-9\.]+) *$/ then
          morph_rate = $1.to_f
        # もし、「rx」「rX」だったら、モーフィングレートを削除
        elsif temp =~ /^ *r[xX] *$/ then
          morph_rate = ""
        # もし、「S<小数>」だったら、スピードスケールを変更
        elsif temp =~ /^ *S([0-9\.]+) *$/ then
          param_speed = $1.to_f
        # もし、「Sx」「SX」だったら、スピードスケールを初期化
        elsif temp =~ /^ *S[xX] *$/ then
          param_speed = 1.0
        # もし、「P<小数>」だったら、ピッチスケールを変更
        elsif temp =~ /^ *P(\-?[0-9\.]+) *$/ then
          param_pitch = $1.to_f
        # もし、「Px」「PX」だったら、ピッチスケールを初期化
        elsif temp =~ /^ *P[xX] *$/ then
          param_pitch = 0.0
        # もし、「I<小数>」だったら、イントネーションスケールを変更
        elsif temp =~ /^ *I([0-9\.]+) *$/ then
          param_intonation = $1.to_f
        # もし、「Ix」「IX」だったら、イントネーションスケールを初期化
        elsif temp =~ /^ *I[xX] *$/ then
          param_intonation = 1.0
        # もし、「V<小数>」だったら、ボリュームスケールを変更
        elsif temp =~ /^ *V([0-9\.]+) *$/ then
          param_volume = $1.to_f
        # もし、「Vx」「VX」だったら、ボリュームスケールを初期化
        elsif temp =~ /^ *V[xX] *$/ then
          param_volume = 1.0
        end
      }
      # 設定部分を削除
      proc_text.sub!(/^ *#\{ *([a-zA-Z0-9,\-\. ]+) *\} */, '')
    end
    # 改行を削除
    proc_text.chomp!
    # スペース、タブ以外の文字があればwavデータに変換する
    if proc_text != /^ *$/ then
      # 詳細メッセージ
      if verbous_flag == 1 then
        STDERR.print("        conv_text=\"#{proc_text}\" srv=\"#{server}\"\n")
      end
      # モーフィングする場合
      if morph_speaker != "" and morph_rate != "" then
        wavdata = text2wav_morph(type, server, proc_text, speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, sample_rate)
      # モーフィングしない場合
      else
        wavdata = text2wav(type, server, proc_text, speaker, query_speaker, param_speed, param_pitch, param_intonation, param_volume, sample_rate)
      end
    end
    return wavdata
  rescue => e
    # エラーが発生したら nil を返す
    STDERR.print "サーバとの通信でエラーが発生しました (e=\"#{e.message}\")\n"
    return nil
  end
end


#----------
# 処理開始
#----------

# デバッグフラグを初期化
@debug_flag = 0

# サーバのタイプを格納する変数
server_type = ""

# 声の種類のデフォルト値をセット
speaker = SPEAKER

# クエリ時の声の種類を初期化
query_speaker = ""

# モーフィング対象の声の種類
morph_speaker = ""
morph_rate = ""

# 最初の無音間隔のデフォルト値をセット
first_silent_time = FIRST_SILENT_TIME

# 最後の無音間隔のデフォルト値をセット
last_silent_time = LAST_SILENT_TIME

# 文章間の間隔のデフォルト値をセット
interval_time = INTERVAL

# 段落間の間隔のデフォルト値をセット
paragraph_interval_time = PARAGRAPH_INTERVAL

# 各種パラメータ
param_speed = 1.0
param_pitch = 0.0
param_intonation = 1.0
param_volume = 1.0

# 出力する音声ファイルのサンプルレート
voicevox_sample_rate = 24000
voicevox_nemo_sample_rate = 24000
coeiroink_sample_rate = 44100

# 入力ファイルを格納する変数
message_file = ""

# 標準出力に音声データを出力するフラグ
stdout_flag = 0

# 入力テキストをそのまま読み上げるフラグ
raw_flag = 0

# 再生フラグを初期化
play_flag = 0

# RDPフラグを初期化
rdp_flag = 0

# mp3変換フラグを初期化
mp3_flag = 0

# 標準出力なしフラグを初期化
quiet_flag = 0

# 出力を増やすフラグを初期化
verbous_flag = 0

# サーバのチェックを行うフラグ
check_flag = 0

# 利用可能なSpeakerID一覧を表示するフラグ
list_flag = 0

# CMU 発音辞書を使用するフラグ
cmudict_flag = 0

# 引数で出力ファイル名が指定された場合にファイル名を格納する変数
output_filename = ""

# 1つのファイルに出力させるフラグを初期化
single_output_flag = 0

# VOICEVOXで指定できるSpeakerIDの最大値
@max_speaker_id = 0

# VOICEVOX NEMOで指定できるSpeakerIDの一覧を格納する配列
@voicevox_nemo_available_speakers = Array.new

# COEIROINKで指定できるSpeakerIDの一覧を格納する配列
@coeiroink_available_speakers = Array.new


# オプションで指定されていたら上書き
opt = OptionParser.new
opt.on('-f', '--file TEXT_FILE', 'テキストファイルの内容を音声変換します'){|v| message_file = v }
opt.on('-o', '--output FILENAME_PREFIX', '出力ファイル名を指定します (拡張子は不要)') {|v| output_filename = v }
opt.on('-1', '--single', 'テキスト全体を1つのファイルに出力します') {|v| single_output_flag = 1 }
opt.on('-p', '--play', 'ファイルに出力せず、全ての音声変換後に読み上げを行います') {|v| play_flag = 1 }
opt.on('-s', '--speaker NUMBER', "声の種類(Speaker ID)を指定します (<数字>、n<数字>, c<数字> または r)") {|v| speaker = v }
opt.on('-m', '--morph_speaker NUMBER,RATE', "モーフィング先の声の種類 (<数字>、n<数字> または c<数字>}) と、モーフィング率 (0.1-0.9) を指定します") {|v| morph_speaker,morph_rate=v.split(",") }
opt.on('--query NUMBER', "クエリ時の声の種類を指定します (<数字>、n<数字> または c<数字>)") {|v| query_speaker = v }
opt.on('-i', '--interval INTERVAL_SECOND', '文章間の時間を指定します (秒)'){|v| interval_time = v.to_f }
opt.on('-I', '--paragraph-interval INTERVAL_SECOND', '文節間の時間を指定します (秒)'){|v| paragraph_interval_time = v.to_f }
opt.on('-q', '--quiet', '標準出力に何も表示しません') {|v| quiet_flag = 1 }
opt.on('-v', '--verbous', '標準出力に読み上げエンジンに渡される文字列も表示します') {|v| verbous_flag = 1 }
opt.on('-c', '--config CONFIG_FILE', '設定ファイルを指定します'){|v| config_file_path = v }
opt.on('-r', '--replace REPLACE_FILE', '置換リストファイルを指定します'){|v| replace_list_file_path = v }
opt.on('--first FIRST_SILENT_TIME', '最初の無音時間を指定します (秒)'){|v| first_silent_time = v.to_f }
opt.on('--last LAST_SILENT_TIME', '最後の無音時間を指定します (秒)'){|v| last_silent_time = v.to_f }
opt.on('--stdout', '全ての音声変換後に音声データを標準出力に出力') {|v| stdout_flag = 1 }
opt.on('--rdp', '再生時、RDP の音声デバイスから再生します') {|v| rdp_flag = 1 }
opt.on('--no-rdp', '再生時、通常の音声デバイスから再生します') {|v| rdp_flag = 2 }
opt.on('--mp3', 'ファイルを mp3 に変換して保存します (対応した sox または ffmpeg が必要です)') {|v| mp3_flag = 1 }
opt.on('--raw', '置換リストやスペース削除などの処理を行わず、入力テキストをそのまま読み上げます') {|v| raw_flag = 1 }
opt.on('--speed SPEED_SCALE', 'スピードスケールを指定します (default=1.0)'){|v| param_speed = v.to_f }
opt.on('--pitch PITCH_SCALE', 'ピッチスケールを指定します (default=0.0)'){|v| param_pitch = v.to_f }
opt.on('--intonation INTONATION_SCALE', 'イントネーションスケールを指定します (default=1.0)'){|v| param_intonation = v.to_f }
opt.on('--volume VOLUME_SCALE', 'ボリュームスケールを指定します (default=1.0)'){|v| param_volume = v.to_f }
opt.on('--cmudict', 'CMU Pronouncing Dictionaryを使用して英語をカナ読みする'){|v| cmudict_flag = 1 }
opt.on('--debug', 'デバッグメッセージを出力します') {|v| @debug_flag = 1 }
opt.on('--check', 'エンジンの状態をチェックします') {|v| check_flag = 1 }
opt.on('--list', '利用可能なSpeaker ID一覧を表示します') {|v| list_flag = 1 }
opt.on('--version', 'バージョンを出力します') {|v| print "#{VERSION}\n" ; exit }
opt.parse!(ARGV)

# デバッグメッセージ表示
debug_print("処理開始")
debug_print("message_file=#{message_file}")
debug_print("play_flag=#{play_flag}")
debug_print("mp3_flag=#{mp3_flag}")
debug_print("quiet_flag=#{quiet_flag}")
debug_print("output_filename=#{output_filename}")

# ENGINEをチェックするフラグが1だったら
if check_flag == 1 then
  debug_print("エンジンの状態をチェックします")
  # VOICEVOX ENGINEの指定があれば
  if (not VOICEVOX_ENGINE.nil?) and VOICEVOX_ENGINE.length > 0 then
    VOICEVOX_ENGINE.each{|server|
      uri = URI.parse("http://#{server}/version")
      http = Net::HTTP.new(uri.host, uri.port)
      res = nil
      begin
        Timeout.timeout(5){
          res = http.get(uri)
        }
      rescue => e
        debug_print("VOICEVOX ENGINE \"#{server}\" 接続時にエラーが発生しました(#{e.message})")
        res = nil
      end
      if (not res.nil?) and res.body =~ /^\"([0-9]+)\.([0-9]+)\.([0-9]+)\"$/ then
        maj_version = $1.to_i
        min_version = $2.to_i
        revision = $3.to_i
        # VOICEVOX ENGINEのバージョンからSpeakerIDの最大値を求める
        VERSION_TO_MAX_SPEAKER_ID.each{|version,maxspeakerid|
          if version =~ /^([0-9]+)\.([0-9]+)\.([0-9]+)$/ then
            maj = $1.to_i
            min = $2.to_i
            rev = $3.to_i
            if (maj_version > maj) or (maj_version == maj and min_version > min) or (maj_version == maj and min_version == min and revision >= rev) then
              @max_speaker_id = VERSION_TO_MAX_SPEAKER_ID[version]
            end
          else
            STDERR.print "VERSION_TO_MAX_SPEAKER_IDのバージョン指定が正しくありません\n"
            exit 1
          end
        }
        print "voicevox engine=#{server} version=#{res.body.chomp} max_speaker_id=#{@max_speaker_id} status=OK\n"
      else
        print "voicevox engine=#{server} status=NG\n"
      end
    }
  end
  # VOICEVOX NEMO ENGINEの指定があれば、指定可能なSpeakerID一覧を求める
  if (not VOICEVOX_NEMO_ENGINE.nil?) and VOICEVOX_NEMO_ENGINE.length > 0 then 
    VOICEVOX_NEMO_ENGINE.each{|server|
      uri = URI.parse("http://#{server}/version")
      http = Net::HTTP.new(uri.host, uri.port)
      res = nil
      begin
        Timeout.timeout(5){
          res = http.get(uri)
        }
      rescue => e
        debug_print("VOICEVOX NEMO ENGINE \"#{server}\" 接続時にエラーが発生しました(#{e.message})")
        res = nil
      end
      if (not res.nil?) then
        @voicevox_nemo_available_speakers = get_available_speakerid(VOICEVOX_NEMO_ENGINE[0], mode="get", type="voicevox_nemo")
        debug_print("server=#{server} voicevox_nemo_available_speakers=#{@voicevox_nemo_available_speakers}")
        print "voicevox nemo engine=#{server} version=#{res.body.chomp} enable_speaker_id=#{@voicevox_nemo_available_speakers} status=OK\n"
      else
        print "voicevox nemo engine=#{server} status=NG\n"
      end
    }
  end
  # COEIROINK ENGINEの指定があれば、指定可能なSpeakerID一覧を求める
  if (not COEIROINK_ENGINE.nil?) and COEIROINK_ENGINE.length > 0 then 
    COEIROINK_ENGINE.each{|server|
      uri = URI.parse("http://#{server}/version")
      http = Net::HTTP.new(uri.host, uri.port)
      res = nil
      begin
        Timeout.timeout(5){
          res = http.get(uri)
        }
      rescue => e
        debug_print("COEIROINK ENGINE \"#{server}\" 接続時にエラーが発生しました(#{e.message})")
        res = nil
      end
      if (not res.nil?) then
        @coeiroink_available_speakers = get_available_speakerid(COEIROINK_ENGINE[0], mode="get", type="coeiroink")
        debug_print("server=#{server} coeiroink_available_speakers=#{@coeiroink_available_speakers}")
        print "coeiroink engine=#{server} version=#{res.body.chomp} enable_speaker_id=#{@coeiroink_available_speakers} status=OK\n"
      else
        print "coeiroink engine=#{server} status=NG\n"
      end
    }
  end
  exit
end

# ランダム声種が指定されたときの選択配列をコピー
random_speaker_id = RANDOM_SPEAKER.dup

# 設定されたVOICEVOX ENGINEのうち使えるものをチェック
if (not VOICEVOX_ENGINE.nil?) and VOICEVOX_ENGINE.length > 0 then
  chk_thread = Array.new
  VOICEVOX_ENGINE.each_with_index{|engine,index|
    # スレッドで各サーバをチェック
    chk_thread[index]=Thread.new{
      uri = URI.parse("http://#{engine}/version")
      http = Net::HTTP.new(uri.host, uri.port)
      res = nil
      begin
        Timeout.timeout(5){
          res = http.get(uri)
        }
      rescue => e
        debug_print("VOICEVOX ENGINE \"#{engine}\" 接続時にエラーが発生しました(#{e.message})")
      end
      if (not res.nil?) and res.code == "200" then
        # VOICEVOX ENGINEのホスト、ポートを返す
        engine
      else
        if quiet_flag == 0 then
          STDERR.print "VOICEVOX ENGINE \"#{engine}\" は使用できないため除外します\n"
        end
        debug_print("VOICEVOX ENGINE \"#{engine}\" は使用できないため除外します")
        nil
      end
    }  
  }
  chk_thread.each {|thr| thr.join }
  @voicevox_engines = Array.new
  chk_thread.each{|thr|
    if not thr.value.nil? then
      @voicevox_engines << thr.value
    end
  }
  if @voicevox_engines.length == 0 then
    if quiet_flag == 0 then
      STDERR.print "全てのVOICEVOX ENGINEが除外されました\n"
    end
    debug_print("全てのVOICEVOX ENGINEが除外されました")
  end
else
  @voicevox_engines = []
end
debug_print("@voicevox_engines=#{@voicevox_engines}")

# 設定されたVOICEVOX NEMO ENGINEのうち使えるものをチェック
if (not VOICEVOX_NEMO_ENGINE.nil?) and VOICEVOX_NEMO_ENGINE.length > 0 then
  chk_thread = Array.new
  VOICEVOX_NEMO_ENGINE.each_with_index{|engine,index|
    # スレッドで各サーバをチェック
    chk_thread[index]=Thread.new{
      uri = URI.parse("http://#{engine}/version")
      http = Net::HTTP.new(uri.host, uri.port)
      res = nil
      begin
        Timeout.timeout(5){
          res = http.get(uri)
        }
      rescue => e
        debug_print("VOICEVOX NEMO ENGINE \"#{engine}\" 接続時にエラーが発生しました(#{e.message})")
        nil
      end
      if (not res.nil?) and res.code == "200" then
        # VOICEVOX NEMO ENGINEのホスト、ポートを返す
        engine
      else
        if quiet_flag == 0 then
          STDERR.print "VOICEVOX NEMO ENGINE \"#{engine}\" は使用できないため除外します\n"
        end
        debug_print("VOICEVOX NEMO ENGINE \"#{engine}\" は使用できないため除外します")
        nil
      end
    }  
  }
  chk_thread.each {|thr| thr.join }
  @voicevox_nemo_engines = Array.new
  chk_thread.each{|thr|
    if not thr.value.nil? then
      @voicevox_nemo_engines << thr.value
    end
  }
  if @voicevox_nemo_engines.length == 0 then
    if quiet_flag == 0 then
      STDERR.print "全てのVOICEVOX NEMO ENGINEが除外されました\n"
    end
    debug_print("全てのVOICEVOX NEMO ENGINEが除外されました")
  end
else
  @voicevox_nemo_engines = []
end
debug_print("@voicevox_nemo_engines=#{@voicevox_nemo_engines}")

# 設定されたCOEIROINK ENGINEのうち使えるものをチェック
if (not COEIROINK_ENGINE.nil?) and COEIROINK_ENGINE.length > 0 then
  chk_thread = Array.new
  COEIROINK_ENGINE.each_with_index{|engine,index|
    # スレッドで各サーバをチェック
    chk_thread[index]=Thread.new{
      uri = URI.parse("http://#{engine}/version")
      http = Net::HTTP.new(uri.host, uri.port)
      res = nil
      begin
        Timeout.timeout(5){
          res = http.get(uri)
        }
      rescue => e
        debug_print("COEIROINK ENGINE \"#{engine}\" 接続時にエラーが発生しました(#{e.message})")
        nil
      end
      if (not res.nil?) and res.code == "200" then
        # COEIROINK ENGINEのホスト、ポートを返す
        engine
      else
        if quiet_flag == 0 then
          STDERR.print "COEIROINK ENGINE \"#{engine}\" は使用できないため除外します\n"
        end
        debug_print("COEIROINK ENGINE \"#{engine}\" は使用できないため除外します")
        nil
      end
    }  
  }
  chk_thread.each {|thr| thr.join }
  @coeiroink_engines = Array.new
  chk_thread.each{|thr|
    if not thr.value.nil? then
      @coeiroink_engines << thr.value
    end
  }
  if @coeiroink_engines.length == 0 then
    if quiet_flag == 0 then
      STDERR.print "全てのCOEIROINK ENGINEが除外されました\n"
    end
    debug_print("全てのCOEIROINK ENGINEが除外されました")
  end
else
  @coeiroink_engines = []
end
debug_print("@coeiroink_engines=#{@coeiroink_engines}")

# 利用可能なSpeaker ID一覧表示を行う場合
if list_flag == 1 then
  # 利用可能なVOICEVOX ENGINEがあれば
  if @voicevox_engines.length > 0 then
    debug_print("利用可能なVOICEVOXのSpeaker IDをチェックします")
    get_available_speakerid(@voicevox_engines[0], 'print', 'voicevox')
  end
  # 利用可能なVOICEVOX NEMO ENGINEがあれば
  if @voicevox_nemo_engines.length > 0 then
    debug_print("利用可能なVOICEVOX NEMOのSpeaker IDをチェックします")
    get_available_speakerid(@voicevox_nemo_engines[0], 'print', 'voicevox_nemo')
  end
  # 利用可能なCOEIROINK ENGINEがあれば
  if @coeiroink_engines.length > 0 then
    debug_print("利用可能なCOEIROINKのSpeaker IDをチェックします")
    get_available_speakerid(@coeiroink_engines[0], 'print', 'coeiroink')
  end
  exit
end


# 設定ファイルで指定された中で使用可能なVOICEVOX ENGINEがあれば
if (not @voicevox_engines.nil?) and @voicevox_engines.length > 0 then
  # 最初のVOICEVOX ENGINEからバージョン番号を取得
  uri = URI.parse("http://#{@voicevox_engines[0]}/version")
  http = Net::HTTP.new(uri.host, uri.port)
  res = nil
  begin
    Timeout.timeout(5){
      res = http.get(uri)
    }
  rescue Timeout::Error
    res = nil
  end
  if (not res.nil?) and res.body =~ /^\"([0-9]+)\.([0-9]+)\.([0-9]+)\"$/ then
    maj_version = $1.to_i
    min_version = $2.to_i
    revision = $3.to_i
  else
    STDERR.print "voicevox engineのバージョン番号を取得できません\n"
    exit 1
  end

  # VOICEVOX ENGINEのバージョンからSpeakerIDの最大値を求める
  VERSION_TO_MAX_SPEAKER_ID.each{|version,maxspeakerid|
    if version =~ /^([0-9]+)\.([0-9]+)\.([0-9]+)$/ then
      maj = $1.to_i
      min = $2.to_i
      rev = $3.to_i
      if maj_version >= maj and min_version >= min and revision >= rev then
        @max_speaker_id = VERSION_TO_MAX_SPEAKER_ID[version]
      end
    else
      STDERR.print "VERSION_TO_MAX_SPEAKER_IDのバージョン指定が正しくありません\n"
      exit 1
    end
  }
  if @max_speaker_id == 0 then
    STDERR.print "指定可能なSperkerIDの最大値が不明です\n"
    exit 1
  end
  # random_speaker_idから、SpeakerIDの最大値より大きな値を削除
  temp_array = Array.new
  random_speaker_id.each{|value|
    if value =~ /^[0-9]+$/ and value.to_i > @max_speaker_id then
      debug_print("VOICEVOXサーバで SpeakerID \"#{value}\" は指定できないためRANDOM_SPEAKERから削除します")
      temp_array << value
    end
  }
  random_speaker_id = random_speaker_id - temp_array
# 使用可能なVOICEVOX ENGINEがなければ、ランダム選択の声種からVOICEVOXのものをすべて取り除く
else
  temp_array = Array.new
  random_speaker_id.each{|value|
    if value =~ /^[0-9]+$/ then
      temp_array << value
    end
  }
  random_speaker_id = random_speaker_id - temp_array
  debug_print("RANDAM_SPEAKERからVOICEVOXの声種を削除しました (RANDOM_SPEAKER=#{random_speaker_id})")
end

# 設定ファイルで指定された中で使用可能なVOICEVOX NEMO ENGINEがあれば、指定可能なSpeakerID一覧を求める
if (not @voicevox_nemo_engines.nil?) and @voicevox_nemo_engines.length > 0 then
  @voicevox_nemo_available_speakers = get_available_speakerid(@voicevox_nemo_engines[0], mode="get", type="voicevox_nemo")
  debug_print("@voicevox_nemo_available_speakers=#{@voicevox_nemo_available_speakers}")
  if @voicevox_nemo_available_speakers.nil? then
    STDERR.print "VOICEVOX NEMOサーバから、指定可能なSpeakerID一覧が取得できません\n"
    exit 1
  end
  # random_speaker_idから、VOICEVOX NEMOサーバで指定できない値を削除
  temp_array = Array.new
  random_speaker_id.each{|value|
    if value =~ /^n([0-9]+)$/ then
      if not @voicevox_nemo_available_speakers.include?($1.to_i) then
        debug_print("VOICEVOX NEMOサーバで SpeakerID \"#{$1}\" は指定できないためRANDOM_SPEAKERから削除します")
        temp_array << value
      end
    end
  }
  random_speaker_id = random_speaker_id - temp_array
# 使用可能なVOICEVOX NEMO ENGINEがなければ、ランダム選択の声種からVOICEVOX NEMOのものを取り除く
else
  temp_array = Array.new
  random_speaker_id.each{|value|
    if value =~ /^n[0-9]+$/ then
      temp_array << value
    end
  }
  random_speaker_id = random_speaker_id - temp_array
  debug_print("RANDAM_SPEAKERからVOICEVOX NEMOの声種を削除しました (RANDOM_SPEAKER=#{random_speaker_id})")
end

# 設定ファイルで指定された中で使用可能なCOEIROINK ENGINEがあれば、指定可能なSpeakerID一覧を求める
if (not @coeiroink_engines.nil?) and @coeiroink_engines.length > 0 then
  @coeiroink_available_speakers = get_available_speakerid(@coeiroink_engines[0], mode="get", type="coeiroink")
  debug_print("@coeiroink_available_speakers=#{@coeiroink_available_speakers}")
  if @coeiroink_available_speakers.nil? then
    STDERR.print "COEIROINKサーバから、指定可能なSpeakerID一覧が取得できません\n"
    exit 1
  end
  # random_speaker_idから、COEIROINKサーバで指定できない値を削除
  temp_array = Array.new
  random_speaker_id.each{|value|
    if value =~ /^c([0-9]+)$/ then
      if not @coeiroink_available_speakers.include?($1.to_i) then
        debug_print("COEIROINKサーバで SpeakerID \"#{$1}\" は指定できないためRANDOM_SPEAKERから削除します")
        temp_array << value
      end
    end
  }
  random_speaker_id = random_speaker_id - temp_array
# 使用可能なCOEIROINK ENGINEがなければ、ランダム選択の声種からCOEIROINKのものを取り除く
else
  temp_array = Array.new
  random_speaker_id.each{|value|
    if value =~ /^c[0-9]+$/ then
      temp_array << value
    end
  }
  random_speaker_id = random_speaker_id - temp_array
  debug_print("RANDAM_SPEAKERからCOEIROINKの声種を削除しました (RANDOM_SPEAKER=#{random_speaker_id})")
end


# speaker の値チェック
debug_print("speaker=#{speaker}")
# VOICEVOXのSpeakerIDが指定された場合
if speaker =~ /^([0-9]+)/ then
  server_type = "voicevox"
  speaker = $1.to_i
  # VOICEVOX ENGINEが指定されていなかったら
  if @voicevox_engines == [] then
    STDERR.print "VOICEVOX ENGINEが設定されていないため、SpeakerID \"#{speaker}\" は指定できません\n"
    exit 1
  end
  # VOICEVOXサーバで使用できないSpeakerIDの場合
  if @max_speaker_id < speaker then
    STDERR.print "VOICEVOX の -s (--speaker)\" の値は、0～#{@max_speaker_id} のいずれかの整数を指定してください\n"
    exit 1
  end
# VOICEVOX NEMOのSpeakerIDが指定された場合
elsif speaker =~ /^n([0-9]+)/ then
  server_type = "voicevox_nemo"
  speaker = $1.to_i
  # VOICEVOX NEMO ENGINEが指定されていなかったら
  if @voicevox_nemo_engines == [] then
    STDERR.print "VOICEVOX NEMO ENGINEが設定されていないため、SpeakerID \"n#{speaker}\" は指定できません\n"
    exit 1
  end
  # VOICEVOX NEMOサーバで使用できないSpeakerIDの場合
  if not @voicevox_nemo_available_speakers.include?(speaker) then
    STDERR.print "-s (--speaker)\" の値は、VOICEVOX NEMOサーバで使用できません\n"
    exit 1
  end
# COEIROINKのSpeakerIDが指定された場合
elsif speaker =~ /^c([0-9]+)/ then
  server_type = "coeiroink"
  speaker = $1.to_i
  # COEIROINK ENGINEが指定されていなかったら
  if @coeiroink_engines == [] then
    STDERR.print "COEIROINK ENGINEが設定されていないため、SpeakerID \"c#{speaker}\" は指定できません\n"
    exit 1
  end
  # COEIROINKサーバで使用できないSpeakerIDの場合
  if not @coeiroink_available_speakers.include?(speaker) then
    STDERR.print "-s (--speaker)\" の値は、COEIROINKサーバで使用できません\n"
    exit 1
  end
# ランダムが指定された場合
elsif speaker =~ /^[Rr]$/ then
  # 配列random_speaker_idから選ばれた値が@max_speaker_id以下になるまで繰り返す
  counter=0
  while true do
    # ランダムな値を選択
    speaker = random_speaker_id.sample
    # VOICEVOXのSpeakerIDが指定された場合
    if speaker =~ /^([0-9]+)$/ then
      speaker = $1.to_i
      if speaker <= @max_speaker_id then
        server_type = "voicevox"
        break
      end
    # VOICEVOX NEMOのSpeakerIDが指定された場合
    elsif speaker =~ /^n([0-9]+)$/ then
      speaker = $1.to_i
      if @voicevox_nemo_available_speakers.include?($1.to_i) then
        server_type = "voicevox_nemo"
        break
      end
    # COEIROINKのSpeakerIDが指定された場合
    elsif speaker =~ /^c([0-9]+)$/ then
      speaker = $1.to_i
      if @coeiroink_available_speakers.include?($1.to_i) then
        server_type = "coeiroink"
        break
      end
    # 1000回ランダム選択しても利用可能なSpeakerIDが選択されない場合は終了
    elsif counter > 1000 then
      STDERR.print "RANDOM_SPEAKERの値からランダムなSpeakerIDを選択しましたが、利用のVOICEVOX/COEIROINK ENGINEで使用できませんでした\n"
      exit 1
    end
    counter+=1
  end
else
  STDERR.print "\"-s (--speaker)\" の値は、\"整数\" \"n整数\" \"c整数\" または \"r\" を指定してください\n"
  exit 1
end

# query_speaker の値チェック
if query_speaker != "" then
  debug_print("query_speaker=#{query_speaker}")
  # もし、query_speakerが「n<数字>」形式だったら「n」を削除する
  if query_speaker =~ /^n([0-9]+)$/ then
    query_speaker = $1
  # もし、query_speakerが「c<数字>」形式だったら「c」を削除する
  elsif query_speaker =~ /^c([0-9]+)$/ then
    query_speaker = $1
  end
  if query_speaker !~ /^[0-9]+$/ then
    STDERR.print "\"--query\" の値は整数で指定してください\n"
    exit 1
  end
  if server_type == "voicevox" then
    if query_speaker.to_i < 0 or @max_speaker_id < query_speaker.to_i then
      STDERR.print "\"--query\" の値は、VOICEVOX ENGINEで使用できないSpeakerIDです。0～#{@max_speaker_id} のいずれかを整数で指定してください\n"
      exit 1
    end
  elsif server_type == "voicevox_nemo" then
    if not @voicevox_nemo_available_speakers.include?(query_speaker.to_i) then
      STDERR.print "\"--query\" の値 \"#{query_speaker}\" は、VOICEVOX NEMO ENGINEで使用できないSpeakerIDです\n"
      exit 1
    end
  elsif server_type == "coeiroink" then
    if not @coeiroink_available_speakers.include?(query_speaker.to_i) then
      STDERR.print "\"--query\" の値 \"#{query_speaker}\" は、COEIROINK ENGINEで使用できないSpeakerIDです\n"
      exit 1
    end
  end
end

# morph_speaker の値チェック
debug_print("morph_speaker=#{morph_speaker}, morph_rate=#{morph_rate}")
# もし、morph_speakerが「n<数字>」形式だったら「n」を削除する
if morph_speaker =~ /^n([0-9]+)$/ then
  morph_speaker = $1
# もし、morph_speakerが「c<数字>」形式だったら「c」を削除する
elsif morph_speaker =~ /^c([0-9]+)$/ then
  morph_speaker = $1
end
if morph_speaker != "" or morph_rate != "" then
  if (not morph_speaker =~ /^[0-9]+$/) or (not morph_rate =~ /^[0-9]\.[0-9]$/) then
    STDERR.print "\"-m (--morph_speaker)\" の値は整数と、0.0～1.0 の小数を「,(カンマ)」でつないだ値にしてください\n"
    exit 1
  end
  if server_type == "voicevox" then
    if morph_rate.to_f < 0.0 or 1.0 < morph_rate.to_f or morph_speaker.to_i < 0 or @max_speaker_id < morph_speaker.to_i then
      STDERR.print "\"-m (--morph_speaker)\" の値は、VOICEVOX ENGINEで使用可能な 0～#{@max_speaker_id} のいずれかのSpeakerIDと、0.0～1.0 の小数を「,(カンマ)」でつないだ値にしてください\n"
      exit 1
    end
  elsif server_type == "voicevox_nemo" then
    if morph_rate.to_f < 0.0 or 1.0 < morph_rate.to_f or (not @voicevox_nemo_available_speakers.include?(query_speaker.to_i)) then
      STDERR.print "\"-m (--morph_speaker)\" の値は、VOICEVOX NEMO ENGINEで使用可能なSpeakerIDと、0.0～1.0 の小数を「,(カンマ)」でつないだ値にしてください\n"
      exit 1
    end
  elsif server_type == "coeiroink" then
    if morph_rate.to_f < 0.0 or 1.0 < morph_rate.to_f or (not @coeiroink_available_speakers.include?(query_speaker.to_i)) then
      STDERR.print "\"-m (--morph_speaker)\" の値は、COEIROINK ENGINEで使用可能なSpeakerIDと、0.0～1.0 の小数を「,(カンマ)」でつないだ値にしてください\n"
      exit 1
    end
  end
end

# first_silent_time の値チェック
debug_print("first_silent_time=#{first_silent_time}")
if #{first_silent_time} =~ /^[0-9\.]$/ then
  STDERR.print "\"-i (--first)\" の値は、数値(小数点可)を指定してください\n"
  exit 1
elsif first_silent_time.to_f < 0 then
  STDERR.print "\"-i (--first)\" は正の値を指定してください\n"
  exit 1
end

# last_silent_time の値チェック
debug_print("last_silent_time=#{last_silent_time}")
if #{last_silent_time} =~ /^[0-9\.]$/ then
  STDERR.print "\"-i (--last)\" の値は、数値(小数点可)を指定してください\n"
  exit 1
elsif last_silent_time.to_f < 0 then
  STDERR.print "\"-i (--last)\" は正の値を指定してください\n"
  exit 1
end

# interval の値チェック
debug_print("interval_time=#{interval_time}")
if #{interval_time} =~ /^[0-9\.]$/ then
  STDERR.print "\"-i (--interval)\" の値は、数値(小数点可)を指定してください\n"
  exit 1
elsif interval_time.to_f < 0 then
  STDERR.print "\"-i (--interval)\" は正の値を指定してください\n"
  exit 1
end

# paragraph_interval_time の値チェック
debug_print("paragraph_interval_time=#{paragraph_interval_time}")
if #{paragraph_interval_time} =~ /^[0-9\.]$/ then
  STDERR.print "\"-i (--paragraph-interval)\" の値は、数値(小数点可)を指定してください\n"
  exit 1
elsif paragraph_interval_time.to_f < 0 then
  STDERR.print "\"-i (--paragraph-interval)\" は正の値を指定してください\n"
  exit 1
end

# 再生フラグが1の場合
if play_flag == 1 then

  #　PLAY_CMD に値「aplay」または「sox」が設定されていたらその値をセットする
  if PLAY_CMD == "aplay" or PLAY_CMD == "sox" then
    play_command = PLAY_CMD
    debug_print("#{play_command}を使用して再生を実行します")
    # コマンドがあるかチェック
    if play_command == "aplay" then
      num = `which #{play_command} | wc -l 2>/dev/null`
      if num.to_i == 0 then
        STDERR.print "音声を再生するためのコマンド \"#{play_command}\" が見つからないため、再生できません\n"
        exit 1
      end
    elsif play_command == "sox" then
      num = `which play | wc -l 2>/dev/null`
      if num.to_i == 0 then
        STDERR.print "音声を再生するためのコマンド \"play(sox)\" が見つからないため、再生できません\n"
        exit 1
      end
    end
  # PLAY_CMD の値が空だったり、正しくない場合は使えるコマンドがないか調べる
  else
    debug_print("再生コマンドを検索します")
    # aplayコマンドがあるかチェック
    num = `which aplay | wc -l 2>/dev/null`
    # aplayコマンドが見つかった場合
    if num.to_i > 0 then
      debug_print("aplayコマンドが見つかりました")
      play_command = "aplay"
    # aplayコマンドが見つからない場合
    else
      # soxコマンドがあるかチェック
      num = `which play | wc -l 2>/dev/null`
      # soxコマンドが見つかった場合
      if num.to_i > 0 then
        debug_print("play(sox)コマンドが見つかりました")
        play_command = "sox"
      # soxコマンドも見つからない場合
      else
        STDERR.print "コマンド \"aplay\" か \"play(sox)\" がともに見つからないため、再生はできません\n"
        exit 1
      end
    end
  end
end

# mp3フラグが1の場合
if mp3_flag == 1 then

  #　CONV_CMD に値「sox」または「ffmpeg」が設定されていたらその値をセットする
  if CONV_CMD == "sox" or CONV_CMD == "ffmpeg" then
    conv_command = CONV_CMD
    debug_print("#{conv_command}を使用してmp3変換を実行します")
    # コマンドがあるかチェック
    num = `which #{conv_command} | wc -l 2>/dev/null`
    if num.to_i == 0 then
      STDERR.print "コマンド \"#{conv_command}\" が見つからないため、mp3 での出力はできません\n"
      exit 1
    end
  # CONV_CMD の値が空だったり、正しくない場合は使えるコマンドがないか調べる
  else
    debug_print("mp3変換コマンドを検索します")
    # soxコマンドがあるかチェック
    num = `which sox | wc -l 2>/dev/null`
    # soxコマンドが見つかった場合
    if num.to_i > 0 then
      debug_print("soxコマンドが見つかりました")
      conv_command = "sox"
    # soxコマンドが見つからない場合
    else
      # ffmpegコマンドがあるかチェック
      num = `which ffmpeg | wc -l 2>/dev/null`
      # ffmpegコマンドが見つかった場合
      if num.to_i > 0 then
        debug_print("ffmpegコマンドが見つかりました")
        conv_command = "ffmpeg"
      # ffmpegコマンドも見つからない場合
      else
        STDERR.print "コマンド \"sox\" か \"ffmpeg\" がともに見つからないため、mp3 での出力はできません\n"
        exit 1
      end
    end
  end

  # 変換コマンドが見つかった場合、一時的に生成するwavファイル名を決めて変数temp_outputに入れる
  if num.to_i > 0 then
    # ランダム文字列を生成
    o = [('a'..'z'), ('A'..'Z'), ('0'..'9')].map { |i| i.to_a }.flatten
    string = (0...8).map { o[rand(o.length)] }.join
    # 一時ファイル名
    temp_output = ".#{string}"
    # デバッグ表示
    debug_print("temp filename = #{temp_output}.wav")
  end
end

# 入力データを格納する変数
input = ""

# 出力ファイル名を格納する変数
outfilename = OUTFILENAME

# テキストデータがパイプで渡された場合
if File.pipe?(STDIN) then

    # デバッグメッセージ
    debug_print("パイプからメッセージを読み込みます")

    # パイプまたはリダイレクトで渡されたデータをすべて読み込む
    while str = $stdin.gets
      input << str
    end
    # 標準入力をttyに切り替える
    #$stdin.reopen('/dev/tty')

# テキストデータがファイルで渡された場合
elsif message_file != "" then

  # デバッグメッセージ
  debug_print("ファイル\"#{message_file}\"からメッセージを読み込みます")

  # テキストファイルが存在すれば中身を読み込む
  if File.exist?(message_file) then

    f = File.open(message_file)
    input = f.read
    f.close

    # ファイル名から「.txt」を取り除いたものを取得
    outfilename = File.basename(message_file, ".txt")

  # テキストファイルが存在しない場合はエラーを表示して終了
  else

    STDERR.print "ファイル \"#{message_file}\" が存在しません\n"
    exit 1

  end

# ファイルでもパイプでもない場合はコマンドオプションからテキストデータを読み込む
else

  # デバッグメッセージ
  debug_print("引数からメッセージを読み込みます")

  # 引数をチェック
  ARGV.each{|strs|
    if input == "" then
      input = strs
    else
      input = "#{input}\n#{strs}"
    end
  }

end

# もし、オプションで出力ファイル名が指定されていたらそれに置き換え
if output_filename != "" then
  # デバッグメッセージ
  debug_print("出力ファイル名の接頭辞を\"#{output_filename}\"に変更します")
  outfilename = output_filename
end

# 変数の初期化
temp_text = ""
conv_text = Array.new

# コメントアウト中であることを示すフラグ
comment_flag = 0

# 読み込んだテキストファイルを1行ごとに処理
input.each_line {|line|

  # 行頭の全角、半角スペース、タブは削除
  line.sub!(/^　 \t+/, '')
  # 行末の全角、半角スペース、タブは削除
  line.sub!(/　 \t+$/, '')

  # もし「//」で始まっているか、「/*」で始まり「*/」で終わっている行はコメントとして無視する
  if line =~ /^\/\// or line =~ /^\/\*.*\*\/$/ then
    next
  # もし、「/*」で始まっていたらコメントアウト開始
  elsif line =~ /^\/\*/ then
    comment_flag = 1
    next
  # もし、コメントアウト中で「*/」で終わっていたらコメントアウト終了
  elsif comment_flag == 1 and line =~ /\*\/$/ then
    comment_flag = 0
    next
  end

  # コメントアウト中であればその行は無視する
  if comment_flag == 1 then
    next
  end

  # 空行(スペースやタブのみの行も空行とみなす)が出てきたら
  if line =~ /^[ 　\t]*$/ then

    # temp_textが空でなければ、配列に入れる
    if temp_text != "" then
      conv_text << temp_text
      temp_text = ""
    end

  # 空行でなければ
  else

    # temp_textに格納
    temp_text += "#{line}"

  end
}


# 最後の行が文字列だったら変換する配列に追加
if temp_text != "" then
  conv_text << temp_text
end

# デバッグメッセージ
debug_print("conv_text=#{conv_text}")

# 変換テキストを格納するハッシュを初期化
input_text = Hash.new

# オリジナルのテキストを格納するハッシュを初期化
orig_text = Hash.new

# CMU 発音辞書を使用したカナ変換を実行する場合
if cmudict_flag == 1 then
  # cmudict.rbを読み込む
  if File.exist?("#{__dir__}/../lib/cmudict.rb") and File.exist?("#{__dir__}/../lib/cmudict.dict") then
    require_relative '../lib/cmudict.rb'
  else
    STDERR.print "\"cmudict.rb\" または \"cmudict.dict\" ファイルが見つかりません\n"
    exit 1
  end
  cmudict = CMUDICT.new
end

# インデックスを初期化
i = 0

# 配列を1つづつ処理
conv_text.each{|text|

  # インデックスを初期化
  j = 0

  # 文章を格納する配列
  text_part = Array.new

  # 「。」または改行で区切って配列に入れる (区切り文字「。」「\n」「?」は消さない)
  text_part = text.split(/(?<=。|\n|\?|？)/)

  # 空の要素があれば削除
  text_part.delete("")

  # 改行だけの要素があれば削除
  text_part.delete("\n")

  # 分割したそれぞれで処理
  text_part.each_with_index {|value,index|

    # orig_text ハッシュに格納
    orig_text["#{i}-#{j}"] = text_part[index]

    # 文頭に「#{s1,q8}」のような記述があったら声の種類のパラメータを変更
    if text_part[index] =~ /^ *#\{ *([a-zA-Z0-9,\. ]+) *\} */ then

      speaker_element = Array.new
      speaker_element = $1.split(",")

      # マッチングした記述を順に処理
      speaker_element.each {|temp|

        # もし、「s<数字>」だったら声の種類を変更
        if temp =~ /^ *s[nc]?[0-9]+ *$/ then
          # 「sn<数字>」だったらVOICEVOX NEMOをセット
          if temp =~ /^ *sn([0-9]+) *$/ then
            speaker = $1
            server_type = "voicevox_nemo"
            if not @voicevox_nemo_available_speakers.include?(speaker.to_i) then
              STDERR.print "指定のspeakerID \"#{speaker}\" は、利用のVOICEVOX NEMO ENGINEで使用できません\n"
              exit 1
            end
          # 「sc<数字>」だったらCOEIROINKをセット
          elsif temp =~ /^ *sc([0-9]+) *$/ then
            speaker = $1
            server_type = "coeiroink"
            if not @coeiroink_available_speakers.include?(speaker.to_i) then
              STDERR.print "指定のspeakerID \"#{speaker}\" は、利用のCOEIROINK ENGINEで使用できません\n"
              exit 1
            end
          #「s<数字>」だったらvoicevoxをセット
          elsif temp =~ /^ *s([0-9]+) *$/ then
            speaker = $1
            server_type = "voicevox"
            if speaker.to_i > @max_speaker_id then
              STDERR.print "指定のspeakerID \"#{speaker}\" は、利用のVOICEVOX ENGINEで使用できません\n"
              exit 1
            end
          end
        # もし、「sr」「sR」だったら声の種類をランダムに設定
        elsif temp =~ /^ *s[rR] *$/ then
          # 配列random_speaker_idから選ばれた値が@max_speaker_id以下になるまで繰り返す
          counter=0
          while true do
            speaker = random_speaker_id.sample
            # VOICEVOX NEMOのSpeakerIDが指定された場合
            if speaker[0] == "n" and speaker =~ /^n([0-9]+)$/ then
              speaker = $1
              if @voicevox_nemo_available_speakers.include?($1.to_i) then
                server_type = "voicevox_nemo"
                break
              end
            # COEIROINKのSpeakerIDが指定された場合
            elsif speaker[0] == "c" and speaker =~ /^c([0-9]+)$/ then
              speaker = $1
              if @coeiroink_available_speakers.include?($1.to_i) then
                server_type = "coeiroink"
                break
              end
            # VoicevoxのSpeakerIDが指定された場合
            elsif speaker =~ /^([0-9]+)$/ then
              if speaker.to_i <=  @max_speaker_id then
                server_type = "voicevox"
                break
              end
            elsif counter > 1000 then
              STDERR.print "random_speaker_idの値からランダムなSpeakerIDを選択しましたが、利用のVOICEVOX/COEIROINK ENGINEで使用できませんでした\n"
              exit 1
            end
            counter+=1
          end
        # もし、「q<数字>」だったら、クエリの声の種類を変更
        elsif temp =~ /^ *q([0-9]+) *$/ then
          query_speaker = $1.to_i
        # もし、「qx」「qX」だったら、クエリの声の種類を削除
        elsif temp =~ /^ *q[xX] *$/ then
          query_speaker = ""
        # もし、「m<数字>」だったら、モーフィング先の声の種類を変更
        elsif temp =~ /^ *m([0-9]+) *$/ then
          morph_speaker = $1.to_i
        # もし、「mx」「mX」だったら、モーフィング先の声の種類を削除
        elsif temp =~ /^ *m[xX] *$/ then
          morph_speaker = ""
        # もし、「r<小数>」だったら、モーフィングレートを変更
        elsif temp =~ /^ *r([0-9\.]+) *$/ then
          morph_rate = $1.to_f
        # もし、「rx」「rX」だったら、モーフィングレートを削除
        elsif temp =~ /^ *r[xX] *$/ then
          morph_rate = ""
        # もし、「S<小数>」だったら、スピードスケールを変更
        elsif temp =~ /^ *S([0-9\.]+) *$/ then
          param_speed = $1.to_f
        # もし、「Sx」「SX」だったら、スピードスケールを初期化
        elsif temp =~ /^ *S[xX] *$/ then
          param_speed = 1.0
        # もし、「P<小数>」だったら、ピッチスケールを変更
        elsif temp =~ /^ *P\-?([0-9\.]+) *$/ then
          param_pitch = $1.to_f
        # もし、「Px」「PX」だったら、ピッチスケールを初期化
        elsif temp =~ /^ *P[xX] *$/ then
          param_pitch = 0.0
        # もし、「I<小数>」だったら、イントネーションスケールを変更
        elsif temp =~ /^ *I([0-9\.]+) *$/ then
          param_intonation = $1.to_f
        # もし、「Ix」「IX」だったら、イントネーションスケールを初期化
        elsif temp =~ /^ *I[xX] *$/ then
          param_intonation = 1.0
        # もし、「V<小数>」だったら、ボリュームスケールを変更
        elsif temp =~ /^ *V([0-9\.]+) *$/ then
          param_volume = $1.to_f
        # もし、「Vx」「VX」だったら、ボリュームスケールを初期化
        elsif temp =~ /^ *V[xX] *$/ then
          param_volume = 1.0
        end

      }

      # 設定部分を削除
      text_part[index].sub!(/^ *#\{ *([a-zA-Z0-9,\. ]+) *\} */, '')

    end

    # もし、タブとスペース以外の文字が残っていれば
    if text_part[index] !~ /^[ \t\r\n]+$/ then

      # 文頭に埋め込む文字列を作成
      if server_type == "voicevox" then
        head_str = "tV,s#{speaker.to_s}"
      elsif server_type == "voicevox_nemo" then
        head_str = "tN,s#{speaker.to_s}"
      elsif server_type == "coeiroink" then
        head_str = "tC,s#{speaker.to_s}"
      end

      # 声の種類
      if query_speaker == "" then
        head_str += ",qX"
      else
        head_str += ",q#{query_speaker.to_s}"
      end

      # モーフィング先の声の種類
      if morph_speaker == "" then
        head_str += ",mX"
      else
        head_str += ",m#{morph_speaker.to_s}"
      end

      # モーフィングレート
      if morph_rate == "" then
        head_str += ",rX"
      else
        head_str += ",r#{morph_rate.to_s}"
      end

      # 各種パラメータ
      head_str += ",S#{param_speed.to_s}"
      head_str += ",P#{param_pitch.to_s}"
      head_str += ",I#{param_intonation.to_s}"
      head_str += ",V#{param_volume.to_s}"

      # 先頭に埋め込む
      text_part[index] =  "#\{#{head_str}\} #{value}"

      # input_text ハッシュに格納
      input_text["#{i}-#{j}"] = text_part[index]

      # インデックスを増加
      j = j + 1
    end
  }


  # 文字列をそのまま読み上げるフラグが0なら
  if raw_flag == 0 then

    # 置換リストを読み込む
    repl_hash = load_replace_list(replace_list_file_path)

    # 文字列の置換処理を実施
    input_text.each {|ikey,ivalue|

      # 置換リストにある言葉を置き換え
      repl_hash.each{|key,value|
        # マッチング文字列に「()」、置換後の文字列に「${<数字>}」がある場合に、マッチした文字列に置き換える
        if input_text[ikey] =~ /#{key}/ then
          # マッチング文字列に「()」記述があり、$1、$2などの変数があればmatch_str配列に格納する
          match_str = Array.new
          k = 1
          while true do
            # $<数字> 変数があれば、配列に追加
            eval("match_str[k] = $#{k} if (not $#{k}.nil?)")
            debug_print("match_str[#{k}] = #{match_str[k]}")
            if match_str[k].nil? then
              break
            end
            k += 1
          end
          # 置換リストの置換後の値に${<数字>}があれば、match_str内の文字列に置き換え
          k = 1
          while true do
            if match_str[k].nil? then
              break
            end
            value.gsub!(/\$\{#{k}\}/, match_str[k])
            k += 1
          end
          debug_print("置換後文字列=#{value}")
        end
        # 置換処理を実行
        input_text[ikey].gsub!(/#{key}/,value)
      }

      # 全角スペース、半角スペース、タブは1つの半角スペースに置き換える
      input_text[ikey].gsub!(/[　 \t]+/, ' ')
      # 文頭の半角スペースは削除
      input_text[ikey].sub!(/^ +/, '')
      # 文末の半角スペースは削除
      input_text[ikey].sub!(/ +$/, '')
      # 文中の半角カナを全角カナに変換
      input_text[ikey] = input_text[ikey].gsub(/[\uFF61-\uFF9F]+/) {|strng| strng.unicode_normalize(:nfkc) }
      # 文中の全角英数字を半角英数字に変換
      input_text[ikey] = input_text[ikey].tr('０-９ａ-ｚＡ-Ｚ','0-9a-zA-Z')
      # 文中の全角記号を半角記号に変換
      input_text[ikey] = input_text[ikey].tr('　！-～',' !-~')
      # 全角「’」を半角「'」に変換(cmu辞書変換で半角「'」が使われるため)
      input_text[ikey] = input_text[ikey].tr('’', '\'')

      # 文中の全角文字と半角英数字間の半角スペースを削除
      if input_text[ikey] =~ /[^\x01-\x7E] +[A-Za-z0-9]+/ then
        input_text[ikey].gsub!( /([^\x01-\x7E]) +([A-Za-z0-9]+)/, "\\1\\2")
      end
      # 文中の半角英数字と全角文字間の半角スペースを削除
      if input_text[ikey] =~ /[A-Za-z0-9]+ +[^\x01-\x7E]/ then
        input_text[ikey].gsub!( /([A-Za-z0-9]+) +([^\x01-\x7E])/, "\\1\\2")
      end
      ## 全角文字同士間のスペースは、意図的に区切りとして入れられていることが多そうなので、コメントアウトしておく
      ## 文中の全角文字と全角文字間の半角スペースを削除(1文字おきにスペースがあると削除漏れがおきるので2回実行)
      #if input_text[ikey] =~ /[^\x01-\x7E] +[^\x01-\x7E]/ then
      #  input_text[ikey].gsub!( /([^\x01-\x7E]) +([^\x01-\x7E])/, "\\1\\2")
      #  input_text[ikey].gsub!( /([^\x01-\x7E]) +([^\x01-\x7E])/, "\\1\\2")
      #end
      # 数字の区切りに使われるカンマは削除
      if input_text[ikey] =~ /[0-9]+,[0-9][0-9][0-9]/ then
        input_text[ikey].gsub!( /([0-9]),([0-9][0-9][0-9])/, "\\1\\2")
      end

    }
  end

  # CMU 発音辞書を使用したカナ変換を実行する場合
  if cmudict_flag == 1 then
    # 文字列の置換処理を実施
    input_text.each {|ikey,ivalue|
      # 先頭に#{s4}のような記述があったら分ける
      if input_text[ikey] =~ /^(#\{[a-zA-Z0-9,\.]+?\})(.*)$/ then
        head = $1
        body = $2
      else
        head = ""
        body = $2
      end
      # 本文に含まれる4文字以上の英単語を置換する
      body2 = body.gsub(/([a-zA-Z'\.\-][a-zA-Z'\.\-][a-zA-Z'\.\-][a-zA-Z'\.\-]+)/){|mword| 
        temp2 = cmudict.word2kana(mword).strip
      }
      input_text[ikey] = head + body2
    }
  end

  # インデックスを増やす
  i = i + 1
}

# VOICEVOXとCOEIROINKで変換する文字列を分ける
voicevox_input_text = Hash.new
voicevox_nemo_input_text = Hash.new
coeiroink_input_text = Hash.new
input_text.each{|key,value|
  if value =~ /^#\{tV,/ then
    voicevox_input_text[key] = value
  elsif value =~ /^#\{tN,/ then
    voicevox_nemo_input_text[key] = value
  elsif value =~ /^#\{tC,/ then
    coeiroink_input_text[key] = value
  end
}
debug_print("voicevox_input_text=#{voicevox_input_text}")
debug_print("voicevox_nemo_input_text=#{voicevox_nemo_input_text}")
debug_print("coeiroink_input_text=#{coeiroink_input_text}")

# 各サーバでの処理が完了したら1になるフラグ
if voicevox_input_text.length > 0 then
  vv_complete_flag = 0
else
  vv_complete_flag = 1
end
if voicevox_nemo_input_text.length > 0 then
  vn_complete_flag = 0
else
  vn_complete_flag = 1
end
if coeiroink_input_text.length > 0 then
  ci_complete_flag = 0
else
  ci_complete_flag = 1
end

# VOICEVOXとCOEIROINK両方を混ぜて音声変換する場合に、サンプリングレートを44100に統一する
if (voicevox_input_text.length > 0 or voicevox_nemo_input_text.length > 0 ) and coeiroink_input_text.length > 0 then
  voicevox_sample_rate = 44100
  voicevox_nemo_sample_rate = 44100
  unite_sample_rate = 44100
# VOICEVOXのみで音声変換する場合は、サンプリングレートは24000
elsif (voicevox_input_text.length > 0 or voicevox_nemo_input_text.length > 0 ) and coeiroink_input_text.length == 0 then
  unite_sample_rate = 24000
# COEIROINKのみで音声変換する場合は、サンプリングレートは44100
else
  unite_sample_rate = 44100
end

# 最終的に出力するWavデータを格納する配列
output_wavdata = Array.new

# 変換した文の数を数えるカウンタの初期化
conv_count = 0
# 変換が必要な文の数
total_count = input_text.length


## VOICEVOXを使用して変換するスレッドを実行する

# VOICEVOXスレッドを格納するハッシュを初期化
vv_threads = Array.new
# VOICEVOXスレッドが処理中の input_text のキーと文字列を格納する配列
vv_thread_key = Array.new
vv_thread_text = Array.new
# VOICEVOXスレッドが使用中のサーバ(エンジン)のインデックスを格納する配列
vv_thread_server = Array.new
# VOICEVOXの使用されていないサーバ(エンジン)を格納する配列
vv_unuse_server = @voicevox_engines.dup

# どのスレッドに割り当てるかを決める変数
i = 0

# 最初のVOICEVOXスレッド実行
voicevox_input_text.each{|key,value|

  # まだ変換すべき文字列と割り当てるサーバ(エンジン)が残っていれば
  if 0 < voicevox_input_text.length and i < @voicevox_engines.length then

    # スレッドが処理中のキー、テキストにセット
    vv_thread_key[i] = key
    vv_thread_text[i] = value

    # 未使用サーバから割り当てるサーバ(エンジン)を削除
    vv_unuse_server.delete(@voicevox_engines[i])

    # スレッドが使用中のサーバ(エンジン)をセット
    vv_thread_server[i] = @voicevox_engines[i]

    # スレッドに渡す用の一時的変数
    server_temp = @voicevox_engines[i]

    # voicevox_input_textから取り除く
    voicevox_input_text.delete(key)

    # 変換した文の数をカウントする変数を増やす
    conv_count = conv_count + 1

    # 進捗表示
    if quiet_flag == 0 then
      STDERR.print "#{conv_count}/#{total_count} [#{key}] \"#{orig_text[key].chomp}\"\n"
    end

    # 詳細メッセージ
    if verbous_flag == 1 then
      STDERR.print "    => \"#{value.chomp}\"\n"
    end

    # スレッドを作成して音声変換を実行させる
    debug_print("create voicevox thread #{i}")
    vv_threads[i] = Thread.new { thread_proc( "voicevox", server_temp, value, speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, voicevox_sample_rate ) }

  # 変換すべき文字列と割り当てるサーバのどちらかがなければ最初のスレッド実行は終了
  else
    break
  end

  # スレッド番号を増やす
  i = i + 1
}


## VOICEVOX NEMOを使用して変換するスレッドを実行する

# VOICEVOX NEMOスレッドを格納するハッシュを初期化
vn_threads = Array.new
# VOICEVOX NEMOスレッドが処理中の input_text のキーと文字列を格納する配列
vn_thread_key = Array.new
vn_thread_text = Array.new
# VOICEVOX NEMOスレッドが使用中のサーバ(エンジン)のインデックスを格納する配列
vn_thread_server = Array.new
# VOICEVOX NEMOの使用されていないサーバ(エンジン)を格納する配列
vn_unuse_server = @voicevox_nemo_engines.dup

# どのスレッドに割り当てるかを決める変数
i = 0

# 最初のVOICEVOX NEMOスレッド実行
voicevox_nemo_input_text.each{|key,value|

  # まだ変換すべき文字列と割り当てるサーバ(エンジン)が残っていれば
  if 0 < voicevox_nemo_input_text.length and i < @voicevox_nemo_engines.length then

    # スレッドが処理中のキー、テキストにセット
    vn_thread_key[i] = key
    vn_thread_text[i] = value

    # 未使用サーバから割り当てるサーバ(エンジン)を削除
    vn_unuse_server.delete(@voicevox_nemo_engines[i])

    # スレッドが使用中のサーバ(エンジン)をセット
    vn_thread_server[i] = @voicevox_nemo_engines[i]

    # スレッドに渡す用の一時的変数
    server_temp = @voicevox_nemo_engines[i]

    # voicevox_nemo_input_textから取り除く
    voicevox_nemo_input_text.delete(key)

    # 変換した文の数をカウントする変数を増やす
    conv_count = conv_count + 1

    # 進捗表示
    if quiet_flag == 0 then
      STDERR.print "#{conv_count}/#{total_count} [#{key}] \"#{orig_text[key].chomp}\"\n"
    end

    # 詳細メッセージ
    if verbous_flag == 1 then
      STDERR.print "    => \"#{value.chomp}\"\n"
    end

    # スレッドを作成して音声変換を実行させる
    debug_print("create voicevox nemo thread #{i}")
    vn_threads[i] = Thread.new { thread_proc( "voicevox_nemo", server_temp, value, speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, voicevox_nemo_sample_rate ) }

  # 変換すべき文字列と割り当てるサーバのどちらかがなければ最初のスレッド実行は終了
  else
    break
  end

  # スレッド番号を増やす
  i = i + 1
}


## COEIROINKを使用して変換するスレッドを実行する

# COEIROINKスレッドを格納するハッシュを初期化
ci_threads = Array.new
# COEIROINKスレッドが処理中の input_text のキーと文字列を格納する配列
ci_thread_key = Array.new
ci_thread_text = Array.new
# COEIROINKスレッドが使用中のサーバ(エンジン)のインデックスを格納する配列
ci_thread_server = Array.new
# COEIROINKの使用されていないサーバ(エンジン)を格納する配列
ci_unuse_server = @coeiroink_engines.dup

# どのスレッドに割り当てるかを決める変数
i = 0

# 最初のCOEIROINKスレッド実行
coeiroink_input_text.each{|key,value|

  # まだ変換すべき文字列と割り当てるサーバ(エンジン)が残っていれば
  if 0 < coeiroink_input_text.length and i < @coeiroink_engines.length then

    # スレッドが処理中のキー、テキストにセット
    ci_thread_key[i] = key
    ci_thread_text[i] = value

    # 未使用サーバから割り当てるサーバ(エンジン)を削除
    ci_unuse_server.delete(@coeiroink_engines[i])

    # スレッドが使用中のサーバ(エンジン)をセット
    ci_thread_server[i] = @coeiroink_engines[i]

    # スレッドに渡す用の一時的変数
    server_temp = @coeiroink_engines[i]

    # voicevox_input_textから取り除く
    coeiroink_input_text.delete(key)

    # 変換した文の数をカウントする変数を増やす
    conv_count = conv_count + 1

    # 進捗表示
    if quiet_flag == 0 then
      STDERR.print "#{conv_count}/#{total_count} [#{key}] \"#{orig_text[key].chomp}\"\n"
    end

    # 詳細メッセージ
    if verbous_flag == 1 then
      STDERR.print "    => \"#{value.chomp}\"\n"
    end

    # スレッドを作成して音声変換を実行させる
    debug_print("create coeiroink thread #{i}")
    ci_threads[i] = Thread.new { thread_proc( "coeiroink", server_temp, value, speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, coeiroink_sample_rate ) }

  # 変換すべき文字列と割り当てるサーバのどちらかがなければ最初のスレッド実行は終了
  else
    break
  end

  # スレッド番号を増やす
  i = i + 1
}


# スレッド実行したらループでスレッドの監視を行う
catch :loop do
  while true

    # 1秒待つ
    sleep 1

    # VOICEVOXの処理が完了していなかったら
    if vv_complete_flag == 0 then
      # VOICEVOXスレッド状態をチェック
      vv_threads.each_with_index{|thr,index|
  
        # VOICEVOXスレッドが異常終了している場合
        if vv_threads[index].status.nil? then
  
          # エラー表示して終了
          debug_print("voicevox thread #{index} が異常終了しました")
          STDERR.print "スレッドが異常終了したため終了します\n"
          exit 1
  
        # VOICEVOXスレッドが正常終了している場合
        elsif vv_threads[index].status == false and vv_thread_key[index] != "" then
  
          # 音声データが返ってきたら
          if not vv_threads[index].value.nil? then
            debug_print("voicevox thread #{index} が正常終了しました")

            # どのインデックスの音声データか調べる
            vv_thread_key[index] =~ /^([0-9]+)\-([0-9]+)$/
            p_num = $1.to_i
            s_num = $2.to_i
  
            # もし output_wavdata[文節番号] が nil であれば空の配列で初期化
            if output_wavdata[p_num].nil? then
              output_wavdata[p_num] = Array.new
            end
  
            # output_wavdata[文節番号][文章番号] に音声データを格納
            output_wavdata[p_num][s_num] = vv_threads[index].value
  
            # まだ voicevox_input_text に残っていたら新しいスレッドを実行する
            if voicevox_input_text.length > 0 then
  
              # voicevox_input_text に残っているデータで新しいスレッドを実行する
              voicevox_input_text.each{|key,value|
  
                # スレッドが処理中のキー、テキストにセット
                vv_thread_key[index] = key
                vv_thread_text[index] = value
  
                # スレッドが使用中のサーバをセット
                server_temp = vv_thread_server[index]
  
                # voicevox_input_textから取り除く
                voicevox_input_text.delete(key)
  
                # 変換した文の数のカウントを増やす
                conv_count = conv_count + 1
  
                # 進捗表示
                if quiet_flag == 0 then
                  STDERR.print "#{conv_count}/#{total_count} [#{key}] \"#{orig_text[key].chomp}\"\n"
                end
  
                # 詳細メッセージ
                if verbous_flag == 1 then
                  STDERR.print "    => \"#{value.chomp}\"\n"
                end
  
                # スレッドを作成して音声変換を実行させる
                debug_print("create voicevox thread #{index}")
                vv_threads[index] = Thread.new { thread_proc( "voicevox", server_temp, value, speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, voicevox_sample_rate ) }
  
                # each文を抜ける
                break
              }
  
            # input_text が空になった場合は新しいスレッドは実行せず、実行中のスレッドの状態をチェック
            else
  
              # VOICEVOXスレッドが使用中のキー、テキスト、サーバをクリア
              vv_thread_key[index] = ""
              vv_thread_text[index] = ""
              vv_thread_server[index] = ""
              break_flag = 1
  
              # 未使用のVOICEVOXサーバに戻す
              vv_unuse_server << vv_thread_server[index]
  
              # 実行中のスレッドがあるかチェック
              vv_thread_key.each_with_index{|tkey|
                # 実行中スレッドがあれば
                if tkey != "" then
                  break_flag = 0
                end
              }
  
              # 実行中のスレッドがなければループを抜ける
              if break_flag == 1 then
                vv_complete_flag = 1
              end
            end
  
          # 音声データ取得に失敗していたら、それ以降そのサーバは使用しない
          else      
  
            STDERR.print "サーバ \"#{vv_thread_server[index]}\" は除外します\n"
            debug_print("vv_unuse_server: #{vv_unuse_server}")
  
            # 未使用のVOICEVOXサーバがなければキー、テキストをvoicevox_input_textに戻す
            if vv_unuse_server.length == 0 then
  
              # 変換した文の数のカウントを減らす
              conv_count = conv_count - 1
  
              # スレッドが処理していたキー、テキストをvoicevox_input_textに戻す
              voicevox_input_text[ vv_thread_key[index] ] = vv_thread_text[index]
  
              # スレッドが使用中のキー、テキスト、サーバをクリア
              vv_thread_key[index] = ""
              vv_thread_text[index] = ""
              vv_thread_server[index] = ""
  
              # 使用可能なVOICEVOXサーバがあるかチェック
              debug_print("voicevox thread: #{vv_thread_server}")
              available_server_flag = 0
              vv_thread_server.each {|thvalue|
                if thvalue != "" then
                  available_server_flag = 1
                end
              }
  
              # 全ての使用可能なVOICEVOXサーバがなくなったらエラー終了
              if available_server_flag == 0 then
                STDERR.print "利用可能なVOICEVOXサーバがありません\n"
                exit 1
              end
  
            # 未使用のVOICEVOXサーバがあればそちらのサーバでスレッドを起動する
            else
  
              # 未使用VOICEVOXサーバの最初のものを割り当て
              vv_thread_server[index] = vv_unuse_server[0]
              vv_unuse_server.delete(vv_thread_server[index])
  
              # VOICEVOXスレッドが使用中のサーバをセット
              server_temp = vv_thread_server[index]
  
              # 進捗表示
              if quiet_flag == 0 then
                STDERR.print "#{conv_count}/#{total_count} [#{vv_thread_key[index]}] \"#{orig_text[vv_thread_key[index]].chomp}\"\n"
              end
  
              # 詳細メッセージ
              if verbous_flag == 1 then
                STDERR.print "    => \"#{vv_thread_text[index].chomp}\"\n"
              end
  
              # VOICEVOXスレッドを作成して音声変換を実行させる
              debug_print("create voicevox thread #{index}")
              vv_threads[index] = Thread.new { thread_proc( "voicevox", server_temp, vv_thread_text[index], speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, voicevox_sample_rate ) }
  
            end
  
          end
        end
      }
    end

    # VOICEVOX NEMOの処理が完了していなかったら
    if vn_complete_flag == 0 then
      # VOICEVOX NEMOスレッド状態をチェック
      vn_threads.each_with_index{|thr,index|
  
        # VOICEVOX NEMOスレッドが異常終了している場合
        if vn_threads[index].status.nil? then
  
          # エラー表示して終了
          debug_print("voicevox nemo thread #{index} が異常終了しました")
          STDERR.print "スレッドが異常終了したため終了します\n"
          exit 1
  
        # VOICEVOX NEMOスレッドが正常終了している場合
        elsif vn_threads[index].status == false and vn_thread_key[index] != "" then
  
          # 音声データが返ってきたら
          if not vn_threads[index].value.nil? then
            debug_print("voicevox nemo thread #{index} が正常終了しました")
  
            # どのインデックスの音声データか調べる
            vn_thread_key[index] =~ /^([0-9]+)\-([0-9]+)$/
            p_num = $1.to_i
            s_num = $2.to_i
  
            # もし output_wavdata[文節番号] が nil であれば空の配列で初期化
            if output_wavdata[p_num].nil? then
              output_wavdata[p_num] = Array.new
            end
  
            # output_wavdata[文節番号][文章番号] に音声データを格納
            output_wavdata[p_num][s_num] = vn_threads[index].value
  
            # まだ voicevox_nemo_input_text に残っていたら新しいスレッドを実行する
            if voicevox_nemo_input_text.length > 0 then
  
              # voicevox_nemo_input_text に残っているデータで新しいスレッドを実行する
              voicevox_nemo_input_text.each{|key,value|
  
                # スレッドが処理中のキー、テキストにセット
                vn_thread_key[index] = key
                vn_thread_text[index] = value
  
                # スレッドが使用中のサーバをセット
                server_temp = vn_thread_server[index]
  
                # voicevox_nemo_input_textから取り除く
                voicevox_nemo_input_text.delete(key)
  
                # 変換した文の数のカウントを増やす
                conv_count = conv_count + 1
  
                # 進捗表示
                if quiet_flag == 0 then
                  STDERR.print "#{conv_count}/#{total_count} [#{key}] \"#{orig_text[key].chomp}\"\n"
                end
  
                # 詳細メッセージ
                if verbous_flag == 1 then
                  STDERR.print "    => \"#{value.chomp}\"\n"
                end
  
                # スレッドを作成して音声変換を実行させる
                debug_print("create voicevox nemo thread #{index}")
                vn_threads[index] = Thread.new { thread_proc( "voicevox_nemo", server_temp, value, speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, voicevox_nemo_sample_rate ) }
  
                # each文を抜ける
                break
              }
  
            # voicevox_nemo_input_text が空になった場合は新しいスレッドは実行せず、実行中のスレッドの状態をチェック
            else
  
              # VOICEVOX NEMOスレッドが使用中のキー、テキスト、サーバをクリア
              vn_thread_key[index] = ""
              vn_thread_text[index] = ""
              vn_thread_server[index] = ""
              break_flag = 1
  
              # 未使用のVOICEVOX NEMOサーバに戻す
              vn_unuse_server << vn_thread_server[index]
  
              # 実行中のスレッドがあるかチェック
              vn_thread_key.each_with_index{|tkey|
                # 実行中スレッドがあれば
                if tkey != "" then
                  break_flag = 0
                end
              }
  
              # 実行中のスレッドがなければci_complete_flagを1にする
              if break_flag == 1 then
                vn_complete_flag = 1
              end
            end
  
          # 音声データ取得に失敗していたら、それ以降そのサーバは使用しない
          else      
  
            STDERR.print "サーバ \"#{vn_thread_server[index]}\" は除外します\n"
            debug_print("vn_unuse_server: #{vn_unuse_server}")
  
            # 未使用のVOICEVOX NEMOサーバがなければキー、テキストをvoicevox_nemo_input_textに戻す
            if vn_unuse_server.length == 0 then
  
              # 変換した文の数のカウントを減らす
              conv_count = conv_count - 1
  
              # スレッドが処理していたキー、テキストをvoicevox_nemo_input_textに戻す
              voicevox_nemo_input_text[ vn_thread_key[index] ] = vn_thread_text[index]
  
              # スレッドが使用中のキー、テキスト、サーバをクリア
              vn_thread_key[index] = ""
              vn_thread_text[index] = ""
              vn_thread_server[index] = ""
  
              # 使用可能なVOICEVOX NEMOサーバがあるかチェック
              debug_print("voicevox nemo thread: #{vn_thread_server}")
              available_server_flag = 0
              vn_thread_server.each {|thvalue|
                if thvalue != "" then
                  available_server_flag = 1
                end
              }
  
              # 全ての使用可能なCOEIROINKサーバがなくなったらエラー終了
              if available_server_flag == 0 then
                STDERR.print "利用可能なVOICEVOX NEMOサーバがありません\n"
                exit 1
              end
  
            # 未使用のVOICEVOX NEMOサーバがあればそちらのサーバでスレッドを起動する
            else
  
              # 未使用VOICEVOX NEMOサーバの最初のものを割り当て
              vn_thread_server[index] = vn_unuse_server[0]
              vn_unuse_server.delete(vn_thread_server[index])
  
              # VOICEVOX NEMOスレッドが使用中のサーバをセット
              server_temp = vn_thread_server[index]
  
              # 進捗表示
              if quiet_flag == 0 then
                STDERR.print "#{conv_count}/#{total_count} [#{vn_thread_key[index]}] \"#{orig_text[vn_thread_key[index]].chomp}\"\n"
              end
  
              # 詳細メッセージ
              if verbous_flag == 1 then
                STDERR.print "    => \"#{vn_thread_text[index].chomp}\"\n"
              end
  
              # VOICEVOX NEMOスレッドを作成して音声変換を実行させる
              debug_print("create voicevox nemo thread #{index}")
              vn_threads[index] = Thread.new { thread_proc( "voicevox_nemo", server_temp, vn_thread_text[index], speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, voicevox_nemo_sample_rate ) }
  
            end
  
          end
        end
      }
    end

    # COEIROINKの処理が完了していなかったら
    if ci_complete_flag == 0 then
      # COEIROINKスレッド状態をチェック
      ci_threads.each_with_index{|thr,index|
  
        # COEIROINKスレッドが異常終了している場合
        if ci_threads[index].status.nil? then
  
          # エラー表示して終了
          debug_print("coeiroink thread #{index} が異常終了しました")
          STDERR.print "スレッドが異常終了したため終了します\n"
          exit 1
  
        # COEIROINKスレッドが正常終了している場合
        elsif ci_threads[index].status == false and ci_thread_key[index] != "" then
  
          # 音声データが返ってきたら
          if not ci_threads[index].value.nil? then
            debug_print("coeiroink thread #{index} が正常終了しました")
  
            # どのインデックスの音声データか調べる
            ci_thread_key[index] =~ /^([0-9]+)\-([0-9]+)$/
            p_num = $1.to_i
            s_num = $2.to_i
  
            # もし output_wavdata[文節番号] が nil であれば空の配列で初期化
            if output_wavdata[p_num].nil? then
              output_wavdata[p_num] = Array.new
            end
  
            # output_wavdata[文節番号][文章番号] に音声データを格納
            output_wavdata[p_num][s_num] = ci_threads[index].value
  
            # まだ coeiroink_input_text に残っていたら新しいスレッドを実行する
            if coeiroink_input_text.length > 0 then
  
              # coeiroink_input_text に残っているデータで新しいスレッドを実行する
              coeiroink_input_text.each{|key,value|
  
                # スレッドが処理中のキー、テキストにセット
                ci_thread_key[index] = key
                ci_thread_text[index] = value
  
                # スレッドが使用中のサーバをセット
                server_temp = ci_thread_server[index]
  
                # coeiroink_input_textから取り除く
                coeiroink_input_text.delete(key)
  
                # 変換した文の数のカウントを増やす
                conv_count = conv_count + 1
  
                # 進捗表示
                if quiet_flag == 0 then
                  STDERR.print "#{conv_count}/#{total_count} [#{key}] \"#{orig_text[key].chomp}\"\n"
                end
  
                # 詳細メッセージ
                if verbous_flag == 1 then
                  STDERR.print "    => \"#{value.chomp}\"\n"
                end
  
                # スレッドを作成して音声変換を実行させる
                debug_print("create coeiroink thread #{index}")
                ci_threads[index] = Thread.new { thread_proc( "coeiroink", server_temp, value, speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, coeiroink_sample_rate ) }
  
                # each文を抜ける
                break
              }
  
            # coeiroink_input_text が空になった場合は新しいスレッドは実行せず、実行中のスレッドの状態をチェック
            else
  
              # COEIROINKスレッドが使用中のキー、テキスト、サーバをクリア
              ci_thread_key[index] = ""
              ci_thread_text[index] = ""
              ci_thread_server[index] = ""
              break_flag = 1
  
              # 未使用のCOEIROINKサーバに戻す
              ci_unuse_server << ci_thread_server[index]
  
              # 実行中のスレッドがあるかチェック
              ci_thread_key.each_with_index{|tkey|
                # 実行中スレッドがあれば
                if tkey != "" then
                  break_flag = 0
                end
              }
  
              # 実行中のスレッドがなければci_complete_flagを1にする
              if break_flag == 1 then
                ci_complete_flag = 1
              end
            end
  
          # 音声データ取得に失敗していたら、それ以降そのサーバは使用しない
          else      
  
            STDERR.print "サーバ \"#{ci_thread_server[index]}\" は除外します\n"
            debug_print("ci_unuse_server: #{ci_unuse_server}")
  
            # 未使用のCOEIROINKサーバがなければキー、テキストをcoeiroink_input_textに戻す
            if ci_unuse_server.length == 0 then
  
              # 変換した文の数のカウントを減らす
              conv_count = conv_count - 1
  
              # スレッドが処理していたキー、テキストをcoeiroink_input_textに戻す
              coeiroink_input_text[ ci_thread_key[index] ] = ci_thread_text[index]
  
              # スレッドが使用中のキー、テキスト、サーバをクリア
              ci_thread_key[index] = ""
              ci_thread_text[index] = ""
              ci_thread_server[index] = ""
  
              # 使用可能なCOEIROINKサーバがあるかチェック
              debug_print("coeiroink thread: #{ci_thread_server}")
              available_server_flag = 0
              ci_thread_server.each {|thvalue|
                if thvalue != "" then
                  available_server_flag = 1
                end
              }
  
              # 全ての使用可能なCOEIROINKサーバがなくなったらエラー終了
              if available_server_flag == 0 then
                STDERR.print "利用可能なCOEIROINKサーバがありません\n"
                exit 1
              end
  
            # 未使用のCOEIROINKサーバがあればそちらのサーバでスレッドを起動する
            else
  
              # 未使用COEIROINKサーバの最初のものを割り当て
              ci_thread_server[index] = ci_unuse_server[0]
              ci_unuse_server.delete(ci_thread_server[index])
  
              # COEIROINKスレッドが使用中のサーバをセット
              server_temp = ci_thread_server[index]
  
              # 進捗表示
              if quiet_flag == 0 then
                STDERR.print "#{conv_count}/#{total_count} [#{ci_thread_key[index]}] \"#{orig_text[ci_thread_key[index]].chomp}\"\n"
              end
  
              # 詳細メッセージ
              if verbous_flag == 1 then
                STDERR.print "    => \"#{ci_thread_text[index].chomp}\"\n"
              end
  
              # COEIROINKスレッドを作成して音声変換を実行させる
              debug_print("create coeiroink thread #{index}")
              ci_threads[index] = Thread.new { thread_proc( "coeiroink", server_temp, ci_thread_text[index], speaker, morph_speaker, morph_rate, query_speaker, param_speed, param_pitch, param_intonation, param_volume, verbous_flag, coeiroink_sample_rate ) }
  
            end
  
          end
        end
      }
    end

    # VOICEVOX、VOICEVOX NEMO、COEIROINKすべての処理が終わったらループを抜ける
    if vv_complete_flag == 1 and vn_complete_flag == 1 and ci_complete_flag == 1 then
      throw :loop
    end
  
  end
end


# 再生するか1 つのファイルに保存する、または標準出力に出力する場合
if play_flag == 1 or single_output_flag == 1 or stdout_flag == 1 then

  # 処理途中で使用する音声データを格納する配列
  temp_wav_list = Array.new

  # 段落内の、文章毎の音声データを繋げる
  output_wavdata.each_with_index {|wav_list, index|

    # 結合して1つのwavデータにしたものをwavデータ配列に追加
    temp_wav_list[index] = unite_wav(wav_list, interval_time, 0.0, 0.0, unite_sample_rate)
  }

  # 段落ごとの音声データを繋げる
  output_wav = unite_wav(temp_wav_list, paragraph_interval_time, first_silent_time, last_silent_time, unite_sample_rate)

  # 標準出力に出力する場合
  if stdout_flag == 1 then

    # デバッグメッセージ
    debug_print("wavデータを標準出力に出力します")

    # 標準出力にwavデータを出力
    STDOUT.binmode
    STDOUT.print output_wav

  # 再生する場合
  elsif play_flag == 1 then

    # デバッグメッセージ
    debug_print("wavデータを再生します")

    # 再生
    play_wav(play_command, output_wav, rdp_flag)

  # wavで保存する場合
  elsif mp3_flag == 0 then

    # 音声データをファイルに保存
    File.binwrite("#{outfilename}.wav", output_wav)

    if quiet_flag == 0 then
      STDERR.print "ファイル \"#{outfilename}.wav\" を保存しました\n"
    end

  # mp3に変換する場合
  else

    # 音声データをファイルに保存
    File.binwrite("#{temp_output}.wav", output_wav)

    # mp3に変換する
    if mp3_flag == 1 then
      retval = conv2mp3(conv_command, temp_output, outfilename)
      if retval == 0 then
        debug_print("#{temp_output}.wav を #{outfilename}.mp3 に変換しました")
        if quiet_flag == 0 then
          STDERR.print "ファイル \"#{outfilename}.mp3\" を保存しました\n"
        end
      else
        debug_print("#{temp_output}.wav の #{outfilename}.mp3 変換に失敗しました")
      end
    end

  end


# 段落ごとに別のファイルに保存する場合
else

  # 段落内の、文章毎の音声データを繋げる
  output_wavdata.each_with_index {|wav_list, index|

    # 連番を求める
    count = index + 1

    # 結合して1つのwavデータにしたものをwavデータ配列に追加
    wavdata = unite_wav(wav_list, interval_time, first_silent_time, last_silent_time, unite_sample_rate)

    # wavで保存する場合
    if mp3_flag == 0 then

      if output_wavdata.length > 1 then
        # デバッグメッセージ
        debug_print("wavデータを連番ファイル\"#{outfilename}_#{count}.wav\"に保存します")
        # 音声データをファイルに保存
        File.binwrite("#{outfilename}_#{count}.wav", wavdata)
        if quiet_flag == 0 then
          STDERR.print "ファイル \"#{outfilename}_#{count}.wav\" を保存しました\n"
        end
      else
        # デバッグメッセージ
        debug_print("wavデータをファイル\"#{outfilename}.wav\"に保存します")
        # 音声データをファイルに保存
        File.binwrite("#{outfilename}.wav", wavdata)
        if quiet_flag == 0 then
          STDERR.print "ファイル \"#{outfilename}.wav\" を保存しました\n"
        end
      end

    # mp3で保存する場合
    else

      # デバッグメッセージ
      debug_print("wavデータを連番ファイル\"#{temp_output}.wav\"に保存します")

      # 音声データをファイルに保存
      File.binwrite("#{temp_output}.wav", wavdata)

      # mp3に変換する
      if mp3_flag == 1 then
        if output_wavdata.length > 1 then
          retval = conv2mp3(conv_command, temp_output, "#{outfilename}_#{count}")
          if retval == 0 then
            debug_print("#{temp_output}.wav を #{outfilename}_#{count}.mp3 に変換しました")
          else
            debug_print("#{temp_output}.wav の #{outfilename}_#{count}.mp3 変換に失敗しました")
          end
          if quiet_flag == 0 then
            STDERR.print "ファイル \"#{outfilename}_#{count}.mp3\" を保存しました\n"
          end
        else
          retval = conv2mp3(conv_command, temp_output, "#{outfilename}")
          if retval == 0 then
            debug_print("#{temp_output}.wav を #{outfilename}.mp3 に変換しました")
          else
            debug_print("#{temp_output}.wav の #{outfilename}.mp3 変換に失敗しました")
          end
          if quiet_flag == 0 then
            STDERR.print "ファイル \"#{outfilename}.mp3\" を保存しました\n"
          end
        end
      end

    end

  }

end

# デバッグメッセージ
debug_print("処理を完了しました")
exit 0
